
// -----------------------------------------------------------------------
//              <- DBC file Rust mapping ->
// -----------------------------------------------------------------------
//  Do not edit this file it will be regenerated automatically by cargo.
//  Check:
//   - build.rs at project root for dynamically mapping
//   - example/demo/dbc-log/??? for static values
//  Reference: iot.bzh/Redpesk canbus-rs code generator
// -----------------------------------------------------------------------

// Tell rustfmt (stable) to skip formatting this whole file
#[rustfmt::skip]

#[allow(
    warnings,
    clippy::all,
    clippy::pedantic,
    clippy::nursery,
    clippy::redundant_field_names,
    clippy::similar_names
)]


// --------------------------------------------------------------
//       WARNING: Manual modification will be destroyed
// --------------------------------------------------------------
// - code generated from ./dbcparser-cli/examples/canforge_dbc_complete_norm/dbc/canforge_dbc_complete_norm.dbc (Wed Jan 28 10:51:38 2026)
// - update only with [dbc-parser|build.rs::DbcParser]
// - source code: https://github.com/redpesk-common/canforge-rs
// Generated file â€” DO NOT EDIT.
// Update only with [dbc-parser|build.rs::DbcParser]
// Source: https://github.com/redpesk-common/canforge-rs
//
// Copyright (C) 2023 IoT.bzh Company
// Author: Fulup Ar Foll <fulup@iot.bzh>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// -------------------------------------------------------------
mod DbcSimple {
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
extern crate serde;

extern crate bitvec;
use sockcan::prelude::*;
use std::cell::{RefCell,RefMut};
use std::rc::{Rc};


/// Vehicle_Status Message
/// - ID: 100 (0x64)
/// - Size: 8 bytes
/// - Transmitter: BODY_CTRL
///
/// Global vehicle status: ignition, speed, steering, doors, ambient temperature.

pub mod VehicleStatus { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        IgnitionState,
        GearPosition,
        VehicleSpeedKph,
        SteeringAngleDeg,
        DoorFlOpen,
        DoorFrOpen,
        DoorRlOpen,
        DoorRrOpen,
        AmbientTempDegC,

    }

    /// VehicleStatus::IgnitionState
    ///
    /// Ignition key/state machine (u8 enum).

    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct IgnitionState {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }

    // DBC definition for MsgID:100 Signal:ignition_state
    #[derive(Serialize, Deserialize)]
    pub enum DbcIgnitionState {
        Off,
        Accessory,
        On,
        Start,

        _Other(u8),
    }

    impl From<DbcIgnitionState> for u8 {
        fn from (val: DbcIgnitionState) -> u8 {
            match val {
                DbcIgnitionState::Off => 0_u8,
                DbcIgnitionState::Accessory => 1_u8,
                DbcIgnitionState::On => 2_u8,
                DbcIgnitionState::Start => 3_u8,

                DbcIgnitionState::_Other(x) => x
            }
        }
    }


    impl IgnitionState  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(IgnitionState {
                status: CanDataStatus::Unset,
                name:"IgnitionState",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }
        pub fn get_as_def (&self) -> DbcIgnitionState {
            match self.get_typed_value() {
                0_u8 => DbcIgnitionState::Off,
                1_u8 => DbcIgnitionState::Accessory,
                2_u8 => DbcIgnitionState::On,
                3_u8 => DbcIgnitionState::Start,
                _ => DbcIgnitionState::_Other(self.get_typed_value()),
            }

        }
        pub fn set_raw_value(&mut self, value: u8, data: &mut[u8]) {
            data.view_bits_mut::<Lsb0>()[0..2].store_le(value);

        }
        pub fn set_as_def (&mut self, signal_def: DbcIgnitionState, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcIgnitionState::Off => Ok(self.set_raw_value(0, data)),
                DbcIgnitionState::Accessory => Ok(self.set_raw_value(1, data)),
                DbcIgnitionState::On => Ok(self.set_raw_value(2, data)),
                DbcIgnitionState::Start => Ok(self.set_raw_value(3, data)),
                DbcIgnitionState::_Other(x) => self.set_typed_value(x,data)
            }
        }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[0..2].store_le(value);

            Ok(())
        }

    } // VehicleStatus::IgnitionState impl end


    impl fmt::Display for IgnitionState {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("IgnitionState:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for IgnitionState {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("IgnitionState")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// VehicleStatus::IgnitionState public api (CanDbcSignal trait)
    impl CanDbcSignal for IgnitionState {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[0..2].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end VehicleStatus::IgnitionState public api

    /// VehicleStatus::GearPosition
    ///
    /// Selected gear (u8 enum).

    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 2
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct GearPosition {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }

    // DBC definition for MsgID:100 Signal:gear_position
    #[derive(Serialize, Deserialize)]
    pub enum DbcGearPosition {
        P,
        R,
        N,
        D,
        B,
        S,
        Unknown,

        _Other(u8),
    }

    impl From<DbcGearPosition> for u8 {
        fn from (val: DbcGearPosition) -> u8 {
            match val {
                DbcGearPosition::P => 0_u8,
                DbcGearPosition::R => 1_u8,
                DbcGearPosition::N => 2_u8,
                DbcGearPosition::D => 3_u8,
                DbcGearPosition::B => 4_u8,
                DbcGearPosition::S => 5_u8,
                DbcGearPosition::Unknown => 6_u8,

                DbcGearPosition::_Other(x) => x
            }
        }
    }


    impl GearPosition  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(GearPosition {
                status: CanDataStatus::Unset,
                name:"GearPosition",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }
        pub fn get_as_def (&self) -> DbcGearPosition {
            match self.get_typed_value() {
                0_u8 => DbcGearPosition::P,
                1_u8 => DbcGearPosition::R,
                2_u8 => DbcGearPosition::N,
                3_u8 => DbcGearPosition::D,
                4_u8 => DbcGearPosition::B,
                5_u8 => DbcGearPosition::S,
                6_u8 => DbcGearPosition::Unknown,
                _ => DbcGearPosition::_Other(self.get_typed_value()),
            }

        }
        pub fn set_raw_value(&mut self, value: u8, data: &mut[u8]) {
            data.view_bits_mut::<Lsb0>()[2..5].store_le(value);

        }
        pub fn set_as_def (&mut self, signal_def: DbcGearPosition, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcGearPosition::P => Ok(self.set_raw_value(0, data)),
                DbcGearPosition::R => Ok(self.set_raw_value(1, data)),
                DbcGearPosition::N => Ok(self.set_raw_value(2, data)),
                DbcGearPosition::D => Ok(self.set_raw_value(3, data)),
                DbcGearPosition::B => Ok(self.set_raw_value(4, data)),
                DbcGearPosition::S => Ok(self.set_raw_value(5, data)),
                DbcGearPosition::Unknown => Ok(self.set_raw_value(6, data)),
                DbcGearPosition::_Other(x) => self.set_typed_value(x,data)
            }
        }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[2..5].store_le(value);

            Ok(())
        }

    } // VehicleStatus::GearPosition impl end


    impl fmt::Display for GearPosition {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("GearPosition:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for GearPosition {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("GearPosition")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// VehicleStatus::GearPosition public api (CanDbcSignal trait)
    impl CanDbcSignal for GearPosition {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[2..5].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end VehicleStatus::GearPosition public api

    /// VehicleStatus::VehicleSpeedKph

    /// - Min: 0
    /// - Max: 300
    /// - Unit: "km/h"
    /// - Receivers: CHASSIS_CTRL
    /// - Start bit: 8
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct VehicleSpeedKph {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl VehicleSpeedKph  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(VehicleSpeedKph {
                status: CanDataStatus::Unset,
                name:"VehicleSpeedKph",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < 0_f64 || 300_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [0..300]",value)));
            }
            let factor = 0.01_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            data.view_bits_mut::<Lsb0>()[8..24].store_le(value);

            Ok(())
        }

    } // VehicleStatus::VehicleSpeedKph impl end


    impl fmt::Display for VehicleSpeedKph {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("VehicleSpeedKph:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for VehicleSpeedKph {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("VehicleSpeedKph")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// VehicleStatus::VehicleSpeedKph public api (CanDbcSignal trait)
    impl CanDbcSignal for VehicleSpeedKph {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[8..24].load_le::<u16>();

                    let factor = 0.01_f64;
                    let offset = 0_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end VehicleStatus::VehicleSpeedKph public api

    /// VehicleStatus::SteeringAngleDeg

    /// - Min: -780
    /// - Max: 780
    /// - Unit: "deg"
    /// - Receivers: CHASSIS_CTRL
    /// - Start bit: 24
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct SteeringAngleDeg {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl SteeringAngleDeg  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SteeringAngleDeg {
                status: CanDataStatus::Unset,
                name:"SteeringAngleDeg",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < -780_f64 || 780_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-780..780]",value)));
            }
            let factor = 0.1_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            let value = u16::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[24..40].store_le(value);

            Ok(())
        }

    } // VehicleStatus::SteeringAngleDeg impl end


    impl fmt::Display for SteeringAngleDeg {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SteeringAngleDeg:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SteeringAngleDeg {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SteeringAngleDeg")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// VehicleStatus::SteeringAngleDeg public api (CanDbcSignal trait)
    impl CanDbcSignal for SteeringAngleDeg {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[24..40].load_le::<u16>();

                    let value = i16::from_ne_bytes(value.to_ne_bytes());

                    let factor = 0.1_f64;
                    let offset = 0_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end VehicleStatus::SteeringAngleDeg public api

    /// VehicleStatus::DoorFlOpen

    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 40
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DoorFlOpen {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<bool>,
    }


    impl DoorFlOpen  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DoorFlOpen {
                status: CanDataStatus::Unset,
                name:"DoorFlOpen",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> bool {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Lsb0>()[40..41].store_le(value);

            Ok(())
        }

    } // VehicleStatus::DoorFlOpen impl end


    impl fmt::Display for DoorFlOpen {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DoorFlOpen:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DoorFlOpen {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DoorFlOpen")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// VehicleStatus::DoorFlOpen public api (CanDbcSignal trait)
    impl CanDbcSignal for DoorFlOpen {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[40..41].load_le::<u8>();

                    let newval = value == 1;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                    };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                        self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end VehicleStatus::DoorFlOpen public api

    /// VehicleStatus::DoorFrOpen

    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 41
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DoorFrOpen {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<bool>,
    }


    impl DoorFrOpen  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DoorFrOpen {
                status: CanDataStatus::Unset,
                name:"DoorFrOpen",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> bool {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Lsb0>()[41..42].store_le(value);

            Ok(())
        }

    } // VehicleStatus::DoorFrOpen impl end


    impl fmt::Display for DoorFrOpen {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DoorFrOpen:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DoorFrOpen {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DoorFrOpen")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// VehicleStatus::DoorFrOpen public api (CanDbcSignal trait)
    impl CanDbcSignal for DoorFrOpen {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[41..42].load_le::<u8>();

                    let newval = value == 1;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                    };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                        self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end VehicleStatus::DoorFrOpen public api

    /// VehicleStatus::DoorRlOpen

    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 42
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DoorRlOpen {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<bool>,
    }


    impl DoorRlOpen  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DoorRlOpen {
                status: CanDataStatus::Unset,
                name:"DoorRlOpen",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> bool {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Lsb0>()[42..43].store_le(value);

            Ok(())
        }

    } // VehicleStatus::DoorRlOpen impl end


    impl fmt::Display for DoorRlOpen {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DoorRlOpen:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DoorRlOpen {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DoorRlOpen")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// VehicleStatus::DoorRlOpen public api (CanDbcSignal trait)
    impl CanDbcSignal for DoorRlOpen {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[42..43].load_le::<u8>();

                    let newval = value == 1;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                    };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                        self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end VehicleStatus::DoorRlOpen public api

    /// VehicleStatus::DoorRrOpen

    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 43
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DoorRrOpen {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<bool>,
    }


    impl DoorRrOpen  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DoorRrOpen {
                status: CanDataStatus::Unset,
                name:"DoorRrOpen",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> bool {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Lsb0>()[43..44].store_le(value);

            Ok(())
        }

    } // VehicleStatus::DoorRrOpen impl end


    impl fmt::Display for DoorRrOpen {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DoorRrOpen:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DoorRrOpen {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DoorRrOpen")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// VehicleStatus::DoorRrOpen public api (CanDbcSignal trait)
    impl CanDbcSignal for DoorRrOpen {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[43..44].load_le::<u8>();

                    let newval = value == 1;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                    };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                        self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end VehicleStatus::DoorRrOpen public api

    /// VehicleStatus::AmbientTempDegC

    /// - Min: -40
    /// - Max: 87
    /// - Unit: "degC"
    /// - Receivers: SENSOR_GATEWAY
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct AmbientTempDegC {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl AmbientTempDegC  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(AmbientTempDegC {
                status: CanDataStatus::Unset,
                name:"AmbientTempDegC",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < -40_f64 || 87_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-40..87]",value)));
            }
            let factor = 1_f64;
            let offset = -40_f64;
            let value = ((value - offset) / factor) as u8;
            let value = u8::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[48..56].store_le(value);

            Ok(())
        }

    } // VehicleStatus::AmbientTempDegC impl end


    impl fmt::Display for AmbientTempDegC {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("AmbientTempDegC:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for AmbientTempDegC {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("AmbientTempDegC")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// VehicleStatus::AmbientTempDegC public api (CanDbcSignal trait)
    impl CanDbcSignal for AmbientTempDegC {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[48..56].load_le::<u8>();

                    let value = i8::from_ne_bytes(value.to_ne_bytes());

                    let factor = 1_f64;
                    let offset = -40_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end VehicleStatus::AmbientTempDegC public api


    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;9],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 100,
                name: "VehicleStatus",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    IgnitionState::new(),
                    GearPosition::new(),
                    VehicleSpeedKph::new(),
                    SteeringAngleDeg::new(),
                    DoorFlOpen::new(),
                    DoorFrOpen::new(),
                    DoorRlOpen::new(),
                    DoorRrOpen::new(),
                    AmbientTempDegC::new(),

                ],
            })))
        }


        pub fn set_values(&mut self, ignition_state: u8, gear_position: u8, vehicle_speed_kph: f64, steering_angle_deg: f64, door_fl_open: bool, door_fr_open: bool, door_rl_open: bool, door_rr_open: bool, ambient_temp_deg_c: f64, frame: &mut[u8]) -> Result<&mut Self, CanError> {


            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(ignition_state), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error ignition_state:U8")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(gear_position), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error gear_position:U8")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(vehicle_speed_kph), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error vehicle_speed_kph:F64")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(steering_angle_deg), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error steering_angle_deg:F64")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(door_fl_open), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error door_fl_open:Bool")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(door_fr_open), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error door_fr_open:Bool")),
            }

            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(door_rl_open), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error door_rl_open:Bool")),
            }

            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(door_rr_open), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error door_rr_open:Bool")),
            }

            match Rc::clone (&self.signals[8]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(ambient_temp_deg_c), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error ambient_temp_deg_c:F64")),
            }

            Ok(self)
        }
    }


    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error ignition_state:U8")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error gear_position:U8")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error vehicle_speed_kph:F64")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error steering_angle_deg:F64")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error door_fl_open:Bool")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error door_fr_open:Bool")),
            }

            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error door_rl_open:Bool")),
            }

            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error door_rr_open:Bool")),
            }

            match Rc::clone (&self.signals[8]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error ambient_temp_deg_c:F64")),
            }

        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error ignition_state:U8")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error gear_position:U8")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error vehicle_speed_kph:F64")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error steering_angle_deg:F64")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error door_fl_open:Bool")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error door_fr_open:Bool")),
            }

            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error door_rl_open:Bool")),
            }

            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error door_rr_open:Bool")),
            }

            match Rc::clone (&self.signals[8]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error ambient_temp_deg_c:F64")),
            }

            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end VehicleStatus impl for CanDbcMessage

} // end VehicleStatus message


/// Energy_Pack_Status Message
/// - ID: 101 (0x65)
/// - Size: 8 bytes
/// - Transmitter: ENERGY_CTRL
///
/// Energy pack electrical status (signed/unsigned, scaling/offset, BE field).

pub mod EnergyPackStatus { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        PackVoltageV,
        PackCurrentA,
        SocPercent,
        SohPercent,
        IsolationKohmBe,
        FaultLevel,

    }

    /// EnergyPackStatus::PackVoltageV

    /// - Min: 0
    /// - Max: 1000
    /// - Unit: "V"
    /// - Receivers: POWERTRAIN_CTRL
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct PackVoltageV {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl PackVoltageV  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PackVoltageV {
                status: CanDataStatus::Unset,
                name:"PackVoltageV",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < 0_f64 || 1000_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [0..1000]",value)));
            }
            let factor = 0.1_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            data.view_bits_mut::<Lsb0>()[0..16].store_le(value);

            Ok(())
        }

    } // EnergyPackStatus::PackVoltageV impl end


    impl fmt::Display for PackVoltageV {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PackVoltageV:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PackVoltageV {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PackVoltageV")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// EnergyPackStatus::PackVoltageV public api (CanDbcSignal trait)
    impl CanDbcSignal for PackVoltageV {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[0..16].load_le::<u16>();

                    let factor = 0.1_f64;
                    let offset = 0_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end EnergyPackStatus::PackVoltageV public api

    /// EnergyPackStatus::PackCurrentA

    /// - Min: -1000
    /// - Max: 1000
    /// - Unit: "A"
    /// - Receivers: POWERTRAIN_CTRL
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct PackCurrentA {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl PackCurrentA  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PackCurrentA {
                status: CanDataStatus::Unset,
                name:"PackCurrentA",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < -1000_f64 || 1000_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-1000..1000]",value)));
            }
            let factor = 0.1_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            let value = u16::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[16..32].store_le(value);

            Ok(())
        }

    } // EnergyPackStatus::PackCurrentA impl end


    impl fmt::Display for PackCurrentA {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PackCurrentA:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PackCurrentA {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PackCurrentA")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// EnergyPackStatus::PackCurrentA public api (CanDbcSignal trait)
    impl CanDbcSignal for PackCurrentA {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[16..32].load_le::<u16>();

                    let value = i16::from_ne_bytes(value.to_ne_bytes());

                    let factor = 0.1_f64;
                    let offset = 0_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end EnergyPackStatus::PackCurrentA public api

    /// EnergyPackStatus::SocPercent

    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: POWERTRAIN_CTRL
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SocPercent {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl SocPercent  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SocPercent {
                status: CanDataStatus::Unset,
                name:"SocPercent",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < 0_f64 || 100_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [0..100]",value)));
            }
            let factor = 0.5_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u8;
            data.view_bits_mut::<Lsb0>()[32..40].store_le(value);

            Ok(())
        }

    } // EnergyPackStatus::SocPercent impl end


    impl fmt::Display for SocPercent {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SocPercent:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SocPercent {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SocPercent")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// EnergyPackStatus::SocPercent public api (CanDbcSignal trait)
    impl CanDbcSignal for SocPercent {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[32..40].load_le::<u8>();

                    let factor = 0.5_f64;
                    let offset = 0_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end EnergyPackStatus::SocPercent public api

    /// EnergyPackStatus::SohPercent

    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: POWERTRAIN_CTRL
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SohPercent {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl SohPercent  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SohPercent {
                status: CanDataStatus::Unset,
                name:"SohPercent",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < 0_f64 || 100_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [0..100]",value)));
            }
            let factor = 0.5_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u8;
            data.view_bits_mut::<Lsb0>()[40..48].store_le(value);

            Ok(())
        }

    } // EnergyPackStatus::SohPercent impl end


    impl fmt::Display for SohPercent {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SohPercent:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SohPercent {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SohPercent")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// EnergyPackStatus::SohPercent public api (CanDbcSignal trait)
    impl CanDbcSignal for SohPercent {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[40..48].load_le::<u8>();

                    let factor = 0.5_f64;
                    let offset = 0_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end EnergyPackStatus::SohPercent public api

    /// EnergyPackStatus::IsolationKohmBe

    /// - Min: 0
    /// - Max: 511
    /// - Unit: "kOhm"
    /// - Receivers: DIAG_TOOL
    /// - Start bit: 55
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct IsolationKohmBe {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u16>,
    }


    impl IsolationKohmBe  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(IsolationKohmBe {
                status: CanDataStatus::Unset,
                name:"IsolationKohmBe",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u16 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[48..57].store_be(value);

            Ok(())
        }

    } // EnergyPackStatus::IsolationKohmBe impl end


    impl fmt::Display for IsolationKohmBe {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("IsolationKohmBe:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for IsolationKohmBe {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("IsolationKohmBe")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// EnergyPackStatus::IsolationKohmBe public api (CanDbcSignal trait)
    impl CanDbcSignal for IsolationKohmBe {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[48..57].load_be::<u16>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end EnergyPackStatus::IsolationKohmBe public api

    /// EnergyPackStatus::FaultLevel

    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: POWERTRAIN_CTRL
    /// - Start bit: 48
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct FaultLevel {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }

    // DBC definition for MsgID:101 Signal:fault_level
    #[derive(Serialize, Deserialize)]
    pub enum DbcFaultLevel {
        None,
        Info,
        Warning,
        Derating,
        Critical,
        Shutdown,

        _Other(u8),
    }

    impl From<DbcFaultLevel> for u8 {
        fn from (val: DbcFaultLevel) -> u8 {
            match val {
                DbcFaultLevel::None => 0_u8,
                DbcFaultLevel::Info => 1_u8,
                DbcFaultLevel::Warning => 2_u8,
                DbcFaultLevel::Derating => 3_u8,
                DbcFaultLevel::Critical => 4_u8,
                DbcFaultLevel::Shutdown => 5_u8,

                DbcFaultLevel::_Other(x) => x
            }
        }
    }


    impl FaultLevel  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(FaultLevel {
                status: CanDataStatus::Unset,
                name:"FaultLevel",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }
        pub fn get_as_def (&self) -> DbcFaultLevel {
            match self.get_typed_value() {
                0_u8 => DbcFaultLevel::None,
                1_u8 => DbcFaultLevel::Info,
                2_u8 => DbcFaultLevel::Warning,
                3_u8 => DbcFaultLevel::Derating,
                4_u8 => DbcFaultLevel::Critical,
                5_u8 => DbcFaultLevel::Shutdown,
                _ => DbcFaultLevel::_Other(self.get_typed_value()),
            }

        }
        pub fn set_raw_value(&mut self, value: u8, data: &mut[u8]) {
            data.view_bits_mut::<Lsb0>()[48..51].store_le(value);

        }
        pub fn set_as_def (&mut self, signal_def: DbcFaultLevel, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcFaultLevel::None => Ok(self.set_raw_value(0, data)),
                DbcFaultLevel::Info => Ok(self.set_raw_value(1, data)),
                DbcFaultLevel::Warning => Ok(self.set_raw_value(2, data)),
                DbcFaultLevel::Derating => Ok(self.set_raw_value(3, data)),
                DbcFaultLevel::Critical => Ok(self.set_raw_value(4, data)),
                DbcFaultLevel::Shutdown => Ok(self.set_raw_value(5, data)),
                DbcFaultLevel::_Other(x) => self.set_typed_value(x,data)
            }
        }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[48..51].store_le(value);

            Ok(())
        }

    } // EnergyPackStatus::FaultLevel impl end


    impl fmt::Display for FaultLevel {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("FaultLevel:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for FaultLevel {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("FaultLevel")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// EnergyPackStatus::FaultLevel public api (CanDbcSignal trait)
    impl CanDbcSignal for FaultLevel {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[48..51].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end EnergyPackStatus::FaultLevel public api


    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;6],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 101,
                name: "EnergyPackStatus",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    PackVoltageV::new(),
                    PackCurrentA::new(),
                    SocPercent::new(),
                    SohPercent::new(),
                    IsolationKohmBe::new(),
                    FaultLevel::new(),

                ],
            })))
        }


        pub fn set_values(&mut self, pack_voltage_v: f64, pack_current_a: f64, soc_percent: f64, soh_percent: f64, isolation_kohm_be: u16, fault_level: u8, frame: &mut[u8]) -> Result<&mut Self, CanError> {


            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(pack_voltage_v), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error pack_voltage_v:F64")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(pack_current_a), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error pack_current_a:F64")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(soc_percent), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error soc_percent:F64")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(soh_percent), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error soh_percent:F64")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(isolation_kohm_be), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error isolation_kohm_be:U16")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(fault_level), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error fault_level:U8")),
            }

            Ok(self)
        }
    }


    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error pack_voltage_v:F64")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error pack_current_a:F64")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error soc_percent:F64")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error soh_percent:F64")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error isolation_kohm_be:U16")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error fault_level:U8")),
            }

        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error pack_voltage_v:F64")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error pack_current_a:F64")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error soc_percent:F64")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error soh_percent:F64")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error isolation_kohm_be:U16")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error fault_level:U8")),
            }

            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end EnergyPackStatus impl for CanDbcMessage

} // end EnergyPackStatus message


/// Powertrain_Mux Message
/// - ID: 200 (0xc8)
/// - Size: 8 bytes
/// - Transmitter: POWERTRAIN_CTRL
///
/// Multiplexed powertrain frame: different payload depending on pt_mux.

pub mod PowertrainMux { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        PtMux,
        AliveCounter,
        Checksum,
        EngineRpm,
        ThrottlePosPercent,
        FuelRateLph,
        MotorTorqueNm,
        MotorSpeedRpm,
        InverterTempDegC,
        DcBusVoltageV,
        DcBusCurrentA,
        RegenEnabled,
        TorqueLimitActive,
        DriverMode,

    }

    /// PowertrainMux::PtMux
    ///
    /// Multiplexor selector (raw values, no scaling).

    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 0
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct PtMux {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl PtMux  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PtMux {
                status: CanDataStatus::Unset,
                name:"PtMux",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[0..4].store_le(value);

            Ok(())
        }

    } // PowertrainMux::PtMux impl end


    impl fmt::Display for PtMux {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PtMux:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PtMux {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PtMux")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// PowertrainMux::PtMux public api (CanDbcSignal trait)
    impl CanDbcSignal for PtMux {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[0..4].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PowertrainMux::PtMux public api

    /// PowertrainMux::AliveCounter

    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 4
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct AliveCounter {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl AliveCounter  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(AliveCounter {
                status: CanDataStatus::Unset,
                name:"AliveCounter",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[4..8].store_le(value);

            Ok(())
        }

    } // PowertrainMux::AliveCounter impl end


    impl fmt::Display for AliveCounter {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("AliveCounter:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for AliveCounter {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("AliveCounter")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// PowertrainMux::AliveCounter public api (CanDbcSignal trait)
    impl CanDbcSignal for AliveCounter {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[4..8].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PowertrainMux::AliveCounter public api

    /// PowertrainMux::Checksum

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct Checksum {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl Checksum  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Checksum {
                status: CanDataStatus::Unset,
                name:"Checksum",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[56..64].store_le(value);

            Ok(())
        }

    } // PowertrainMux::Checksum impl end


    impl fmt::Display for Checksum {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Checksum:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Checksum {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Checksum")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// PowertrainMux::Checksum public api (CanDbcSignal trait)
    impl CanDbcSignal for Checksum {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[56..64].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PowertrainMux::Checksum public api

    /// PowertrainMux::EngineRpm

    /// - Min: 0
    /// - Max: 8000
    /// - Unit: "rpm"
    /// - Receivers: LOGGER
    /// - Start bit: 8
    /// - Signal size: 16 bits
    /// - Factor: 0.25
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct EngineRpm {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl EngineRpm  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(EngineRpm {
                status: CanDataStatus::Unset,
                name:"EngineRpm",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < 0_f64 || 8000_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [0..8000]",value)));
            }
            let factor = 0.25_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            data.view_bits_mut::<Lsb0>()[8..24].store_le(value);

            Ok(())
        }

    } // PowertrainMux::EngineRpm impl end


    impl fmt::Display for EngineRpm {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("EngineRpm:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for EngineRpm {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("EngineRpm")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// PowertrainMux::EngineRpm public api (CanDbcSignal trait)
    impl CanDbcSignal for EngineRpm {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[8..24].load_le::<u16>();

                    let factor = 0.25_f64;
                    let offset = 0_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PowertrainMux::EngineRpm public api

    /// PowertrainMux::ThrottlePosPercent

    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: LOGGER
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct ThrottlePosPercent {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl ThrottlePosPercent  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(ThrottlePosPercent {
                status: CanDataStatus::Unset,
                name:"ThrottlePosPercent",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < 0_f64 || 100_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [0..100]",value)));
            }
            let factor = 0.4_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u8;
            data.view_bits_mut::<Lsb0>()[24..32].store_le(value);

            Ok(())
        }

    } // PowertrainMux::ThrottlePosPercent impl end


    impl fmt::Display for ThrottlePosPercent {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("ThrottlePosPercent:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for ThrottlePosPercent {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("ThrottlePosPercent")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// PowertrainMux::ThrottlePosPercent public api (CanDbcSignal trait)
    impl CanDbcSignal for ThrottlePosPercent {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[24..32].load_le::<u8>();

                    let factor = 0.4_f64;
                    let offset = 0_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PowertrainMux::ThrottlePosPercent public api

    /// PowertrainMux::FuelRateLph

    /// - Min: 0
    /// - Max: 200
    /// - Unit: "L/h"
    /// - Receivers: LOGGER
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct FuelRateLph {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl FuelRateLph  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(FuelRateLph {
                status: CanDataStatus::Unset,
                name:"FuelRateLph",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < 0_f64 || 200_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [0..200]",value)));
            }
            let factor = 0.01_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            data.view_bits_mut::<Lsb0>()[32..48].store_le(value);

            Ok(())
        }

    } // PowertrainMux::FuelRateLph impl end


    impl fmt::Display for FuelRateLph {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("FuelRateLph:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for FuelRateLph {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("FuelRateLph")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// PowertrainMux::FuelRateLph public api (CanDbcSignal trait)
    impl CanDbcSignal for FuelRateLph {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[32..48].load_le::<u16>();

                    let factor = 0.01_f64;
                    let offset = 0_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PowertrainMux::FuelRateLph public api

    /// PowertrainMux::MotorTorqueNm

    /// - Min: -600
    /// - Max: 600
    /// - Unit: "Nm"
    /// - Receivers: LOGGER
    /// - Start bit: 8
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct MotorTorqueNm {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl MotorTorqueNm  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(MotorTorqueNm {
                status: CanDataStatus::Unset,
                name:"MotorTorqueNm",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < -600_f64 || 600_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-600..600]",value)));
            }
            let factor = 0.1_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            let value = u16::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[8..24].store_le(value);

            Ok(())
        }

    } // PowertrainMux::MotorTorqueNm impl end


    impl fmt::Display for MotorTorqueNm {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("MotorTorqueNm:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for MotorTorqueNm {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("MotorTorqueNm")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// PowertrainMux::MotorTorqueNm public api (CanDbcSignal trait)
    impl CanDbcSignal for MotorTorqueNm {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[8..24].load_le::<u16>();

                    let value = i16::from_ne_bytes(value.to_ne_bytes());

                    let factor = 0.1_f64;
                    let offset = 0_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PowertrainMux::MotorTorqueNm public api

    /// PowertrainMux::MotorSpeedRpm

    /// - Min: -20000
    /// - Max: 20000
    /// - Unit: "rpm"
    /// - Receivers: LOGGER
    /// - Start bit: 24
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct MotorSpeedRpm {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<i16>,
    }


    impl MotorSpeedRpm  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(MotorSpeedRpm {
                status: CanDataStatus::Unset,
                name:"MotorSpeedRpm",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> i16 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:i16, data:&mut [u8]) -> Result<(),CanError> {
            let value = u16::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[24..40].store_le(value);

            Ok(())
        }

    } // PowertrainMux::MotorSpeedRpm impl end


    impl fmt::Display for MotorSpeedRpm {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("MotorSpeedRpm:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for MotorSpeedRpm {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("MotorSpeedRpm")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// PowertrainMux::MotorSpeedRpm public api (CanDbcSignal trait)
    impl CanDbcSignal for MotorSpeedRpm {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[24..40].load_le::<u16>();

                    let value = i16::from_ne_bytes(value.to_ne_bytes());

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:i16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::I16(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PowertrainMux::MotorSpeedRpm public api

    /// PowertrainMux::InverterTempDegC

    /// - Min: -40
    /// - Max: 215
    /// - Unit: "degC"
    /// - Receivers: LOGGER
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct InverterTempDegC {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl InverterTempDegC  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(InverterTempDegC {
                status: CanDataStatus::Unset,
                name:"InverterTempDegC",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < -40_f64 || 215_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-40..215]",value)));
            }
            let factor = 1_f64;
            let offset = -40_f64;
            let value = ((value - offset) / factor) as u8;
            let value = u8::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[8..16].store_le(value);

            Ok(())
        }

    } // PowertrainMux::InverterTempDegC impl end


    impl fmt::Display for InverterTempDegC {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("InverterTempDegC:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for InverterTempDegC {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("InverterTempDegC")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// PowertrainMux::InverterTempDegC public api (CanDbcSignal trait)
    impl CanDbcSignal for InverterTempDegC {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[8..16].load_le::<u8>();

                    let value = i8::from_ne_bytes(value.to_ne_bytes());

                    let factor = 1_f64;
                    let offset = -40_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PowertrainMux::InverterTempDegC public api

    /// PowertrainMux::DcBusVoltageV

    /// - Min: 0
    /// - Max: 1000
    /// - Unit: "V"
    /// - Receivers: LOGGER
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DcBusVoltageV {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl DcBusVoltageV  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DcBusVoltageV {
                status: CanDataStatus::Unset,
                name:"DcBusVoltageV",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < 0_f64 || 1000_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [0..1000]",value)));
            }
            let factor = 0.1_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            data.view_bits_mut::<Lsb0>()[16..32].store_le(value);

            Ok(())
        }

    } // PowertrainMux::DcBusVoltageV impl end


    impl fmt::Display for DcBusVoltageV {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DcBusVoltageV:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DcBusVoltageV {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DcBusVoltageV")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// PowertrainMux::DcBusVoltageV public api (CanDbcSignal trait)
    impl CanDbcSignal for DcBusVoltageV {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[16..32].load_le::<u16>();

                    let factor = 0.1_f64;
                    let offset = 0_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PowertrainMux::DcBusVoltageV public api

    /// PowertrainMux::DcBusCurrentA

    /// - Min: -1000
    /// - Max: 1000
    /// - Unit: "A"
    /// - Receivers: LOGGER
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct DcBusCurrentA {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl DcBusCurrentA  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DcBusCurrentA {
                status: CanDataStatus::Unset,
                name:"DcBusCurrentA",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < -1000_f64 || 1000_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-1000..1000]",value)));
            }
            let factor = 0.1_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            let value = u16::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[32..48].store_le(value);

            Ok(())
        }

    } // PowertrainMux::DcBusCurrentA impl end


    impl fmt::Display for DcBusCurrentA {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DcBusCurrentA:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DcBusCurrentA {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DcBusCurrentA")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// PowertrainMux::DcBusCurrentA public api (CanDbcSignal trait)
    impl CanDbcSignal for DcBusCurrentA {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[32..48].load_le::<u16>();

                    let value = i16::from_ne_bytes(value.to_ne_bytes());

                    let factor = 0.1_f64;
                    let offset = 0_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PowertrainMux::DcBusCurrentA public api

    /// PowertrainMux::RegenEnabled

    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct RegenEnabled {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<bool>,
    }


    impl RegenEnabled  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(RegenEnabled {
                status: CanDataStatus::Unset,
                name:"RegenEnabled",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> bool {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Lsb0>()[8..9].store_le(value);

            Ok(())
        }

    } // PowertrainMux::RegenEnabled impl end


    impl fmt::Display for RegenEnabled {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("RegenEnabled:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for RegenEnabled {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("RegenEnabled")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// PowertrainMux::RegenEnabled public api (CanDbcSignal trait)
    impl CanDbcSignal for RegenEnabled {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[8..9].load_le::<u8>();

                    let newval = value == 1;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                    };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                        self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PowertrainMux::RegenEnabled public api

    /// PowertrainMux::TorqueLimitActive

    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct TorqueLimitActive {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<bool>,
    }


    impl TorqueLimitActive  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(TorqueLimitActive {
                status: CanDataStatus::Unset,
                name:"TorqueLimitActive",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> bool {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Lsb0>()[9..10].store_le(value);

            Ok(())
        }

    } // PowertrainMux::TorqueLimitActive impl end


    impl fmt::Display for TorqueLimitActive {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("TorqueLimitActive:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for TorqueLimitActive {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("TorqueLimitActive")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// PowertrainMux::TorqueLimitActive public api (CanDbcSignal trait)
    impl CanDbcSignal for TorqueLimitActive {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[9..10].load_le::<u8>();

                    let newval = value == 1;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                    };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                        self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PowertrainMux::TorqueLimitActive public api

    /// PowertrainMux::DriverMode

    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DriverMode {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }

    // DBC definition for MsgID:200 Signal:driver_mode
    #[derive(Serialize, Deserialize)]
    pub enum DbcDriverMode {
        Eco,
        Normal,
        Sport,
        Track,

        _Other(u8),
    }

    impl From<DbcDriverMode> for u8 {
        fn from (val: DbcDriverMode) -> u8 {
            match val {
                DbcDriverMode::Eco => 0_u8,
                DbcDriverMode::Normal => 1_u8,
                DbcDriverMode::Sport => 2_u8,
                DbcDriverMode::Track => 3_u8,

                DbcDriverMode::_Other(x) => x
            }
        }
    }


    impl DriverMode  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DriverMode {
                status: CanDataStatus::Unset,
                name:"DriverMode",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }
        pub fn get_as_def (&self) -> DbcDriverMode {
            match self.get_typed_value() {
                0_u8 => DbcDriverMode::Eco,
                1_u8 => DbcDriverMode::Normal,
                2_u8 => DbcDriverMode::Sport,
                3_u8 => DbcDriverMode::Track,
                _ => DbcDriverMode::_Other(self.get_typed_value()),
            }

        }
        pub fn set_raw_value(&mut self, value: u8, data: &mut[u8]) {
            data.view_bits_mut::<Lsb0>()[10..12].store_le(value);

        }
        pub fn set_as_def (&mut self, signal_def: DbcDriverMode, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcDriverMode::Eco => Ok(self.set_raw_value(0, data)),
                DbcDriverMode::Normal => Ok(self.set_raw_value(1, data)),
                DbcDriverMode::Sport => Ok(self.set_raw_value(2, data)),
                DbcDriverMode::Track => Ok(self.set_raw_value(3, data)),
                DbcDriverMode::_Other(x) => self.set_typed_value(x,data)
            }
        }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[10..12].store_le(value);

            Ok(())
        }

    } // PowertrainMux::DriverMode impl end


    impl fmt::Display for DriverMode {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DriverMode:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DriverMode {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DriverMode")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// PowertrainMux::DriverMode public api (CanDbcSignal trait)
    impl CanDbcSignal for DriverMode {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[10..12].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PowertrainMux::DriverMode public api


    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;14],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 200,
                name: "PowertrainMux",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    PtMux::new(),
                    AliveCounter::new(),
                    Checksum::new(),
                    EngineRpm::new(),
                    ThrottlePosPercent::new(),
                    FuelRateLph::new(),
                    MotorTorqueNm::new(),
                    MotorSpeedRpm::new(),
                    InverterTempDegC::new(),
                    DcBusVoltageV::new(),
                    DcBusCurrentA::new(),
                    RegenEnabled::new(),
                    TorqueLimitActive::new(),
                    DriverMode::new(),

                ],
            })))
        }


        pub fn set_values(&mut self, pt_mux: u8, alive_counter: u8, checksum: u8, engine_rpm: f64, throttle_pos_percent: f64, fuel_rate_lph: f64, motor_torque_nm: f64, motor_speed_rpm: i16, inverter_temp_deg_c: f64, dc_bus_voltage_v: f64, dc_bus_current_a: f64, regen_enabled: bool, torque_limit_active: bool, driver_mode: u8, frame: &mut[u8]) -> Result<&mut Self, CanError> {


            let __mux_raw_value: u64 = pt_mux as u64;
            println!("RLM __mux_raw_value{}",__mux_raw_value);

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(pt_mux), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error pt_mux:U8")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(alive_counter), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error alive_counter:U8")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(checksum), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error checksum:U8")),
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[3]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::F64(engine_rpm), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error engine_rpm:F64")),
                }
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[4]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::F64(throttle_pos_percent), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error throttle_pos_percent:F64")),
                }
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[5]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::F64(fuel_rate_lph), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error fuel_rate_lph:F64")),
                }
            }

            if __mux_raw_value == 1 {
                match Rc::clone (&self.signals[6]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::F64(motor_torque_nm), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error motor_torque_nm:F64")),
                }
            }

            if __mux_raw_value == 1 {
                match Rc::clone (&self.signals[7]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::I16(motor_speed_rpm), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error motor_speed_rpm:I16")),
                }
            }

            if __mux_raw_value == 2 {
                match Rc::clone (&self.signals[8]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::F64(inverter_temp_deg_c), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error inverter_temp_deg_c:F64")),
                }
            }

            if __mux_raw_value == 2 {
                match Rc::clone (&self.signals[9]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::F64(dc_bus_voltage_v), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error dc_bus_voltage_v:F64")),
                }
            }

            if __mux_raw_value == 2 {
                match Rc::clone (&self.signals[10]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::F64(dc_bus_current_a), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error dc_bus_current_a:F64")),
                }
            }

            if __mux_raw_value == 3 {
                match Rc::clone (&self.signals[11]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::Bool(regen_enabled), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error regen_enabled:Bool")),
                }
            }

            if __mux_raw_value == 3 {
                match Rc::clone (&self.signals[12]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::Bool(torque_limit_active), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error torque_limit_active:Bool")),
                }
            }

            if __mux_raw_value == 3 {
                match Rc::clone (&self.signals[13]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::U8(driver_mode), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error driver_mode:U8")),
                }
            }

            Ok(self)
        }
    }


    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error pt_mux:U8")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error alive_counter:U8")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error checksum:U8")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error engine_rpm:F64")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error throttle_pos_percent:F64")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error fuel_rate_lph:F64")),
            }

            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error motor_torque_nm:F64")),
            }

            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error motor_speed_rpm:I16")),
            }

            match Rc::clone (&self.signals[8]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error inverter_temp_deg_c:F64")),
            }

            match Rc::clone (&self.signals[9]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error dc_bus_voltage_v:F64")),
            }

            match Rc::clone (&self.signals[10]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error dc_bus_current_a:F64")),
            }

            match Rc::clone (&self.signals[11]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error regen_enabled:Bool")),
            }

            match Rc::clone (&self.signals[12]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error torque_limit_active:Bool")),
            }

            match Rc::clone (&self.signals[13]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error driver_mode:U8")),
            }

        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;

            let __mux_raw_value: u64 = (frame.data.view_bits::<Lsb0>()[0..4].load_le::<u8>()) as u64;

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error pt_mux:U8")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error alive_counter:U8")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error checksum:U8")),
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[3]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error engine_rpm:F64")),
                }
            } else {
                match Rc::clone (&self.signals[3]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error engine_rpm:F64")),
                }
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[4]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error throttle_pos_percent:F64")),
                }
            } else {
                match Rc::clone (&self.signals[4]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error throttle_pos_percent:F64")),
                }
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[5]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error fuel_rate_lph:F64")),
                }
            } else {
                match Rc::clone (&self.signals[5]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error fuel_rate_lph:F64")),
                }
            }

            if __mux_raw_value == 1 {
                match Rc::clone (&self.signals[6]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error motor_torque_nm:F64")),
                }
            } else {
                match Rc::clone (&self.signals[6]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error motor_torque_nm:F64")),
                }
            }

            if __mux_raw_value == 1 {
                match Rc::clone (&self.signals[7]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error motor_speed_rpm:I16")),
                }
            } else {
                match Rc::clone (&self.signals[7]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error motor_speed_rpm:I16")),
                }
            }

            if __mux_raw_value == 2 {
                match Rc::clone (&self.signals[8]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error inverter_temp_deg_c:F64")),
                }
            } else {
                match Rc::clone (&self.signals[8]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error inverter_temp_deg_c:F64")),
                }
            }

            if __mux_raw_value == 2 {
                match Rc::clone (&self.signals[9]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error dc_bus_voltage_v:F64")),
                }
            } else {
                match Rc::clone (&self.signals[9]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error dc_bus_voltage_v:F64")),
                }
            }

            if __mux_raw_value == 2 {
                match Rc::clone (&self.signals[10]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error dc_bus_current_a:F64")),
                }
            } else {
                match Rc::clone (&self.signals[10]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error dc_bus_current_a:F64")),
                }
            }

            if __mux_raw_value == 3 {
                match Rc::clone (&self.signals[11]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error regen_enabled:Bool")),
                }
            } else {
                match Rc::clone (&self.signals[11]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error regen_enabled:Bool")),
                }
            }

            if __mux_raw_value == 3 {
                match Rc::clone (&self.signals[12]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error torque_limit_active:Bool")),
                }
            } else {
                match Rc::clone (&self.signals[12]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error torque_limit_active:Bool")),
                }
            }

            if __mux_raw_value == 3 {
                match Rc::clone (&self.signals[13]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error driver_mode:U8")),
                }
            } else {
                match Rc::clone (&self.signals[13]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error driver_mode:U8")),
                }
            }

            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end PowertrainMux impl for CanDbcMessage

} // end PowertrainMux message


/// Chassis_Control Message
/// - ID: 210 (0xd2)
/// - Size: 8 bytes
/// - Transmitter: CHASSIS_CTRL

pub mod ChassisControl { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        AbsActive,
        EscActive,
        BrakePressureBar,
        YawRateDps,
        LatAccelMps2,
        WheelFlKph,

    }

    /// ChassisControl::AbsActive

    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct AbsActive {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<bool>,
    }


    impl AbsActive  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(AbsActive {
                status: CanDataStatus::Unset,
                name:"AbsActive",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> bool {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Lsb0>()[0..1].store_le(value);

            Ok(())
        }

    } // ChassisControl::AbsActive impl end


    impl fmt::Display for AbsActive {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("AbsActive:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for AbsActive {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("AbsActive")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// ChassisControl::AbsActive public api (CanDbcSignal trait)
    impl CanDbcSignal for AbsActive {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[0..1].load_le::<u8>();

                    let newval = value == 1;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                    };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                        self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end ChassisControl::AbsActive public api

    /// ChassisControl::EscActive

    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct EscActive {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<bool>,
    }


    impl EscActive  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(EscActive {
                status: CanDataStatus::Unset,
                name:"EscActive",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> bool {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Lsb0>()[1..2].store_le(value);

            Ok(())
        }

    } // ChassisControl::EscActive impl end


    impl fmt::Display for EscActive {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("EscActive:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for EscActive {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("EscActive")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// ChassisControl::EscActive public api (CanDbcSignal trait)
    impl CanDbcSignal for EscActive {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[1..2].load_le::<u8>();

                    let newval = value == 1;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                    };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                        self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end ChassisControl::EscActive public api

    /// ChassisControl::BrakePressureBar

    /// - Min: 0
    /// - Max: 300
    /// - Unit: "bar"
    /// - Receivers: LOGGER
    /// - Start bit: 8
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct BrakePressureBar {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl BrakePressureBar  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(BrakePressureBar {
                status: CanDataStatus::Unset,
                name:"BrakePressureBar",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < 0_f64 || 300_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [0..300]",value)));
            }
            let factor = 0.1_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            data.view_bits_mut::<Lsb0>()[8..24].store_le(value);

            Ok(())
        }

    } // ChassisControl::BrakePressureBar impl end


    impl fmt::Display for BrakePressureBar {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("BrakePressureBar:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for BrakePressureBar {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("BrakePressureBar")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// ChassisControl::BrakePressureBar public api (CanDbcSignal trait)
    impl CanDbcSignal for BrakePressureBar {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[8..24].load_le::<u16>();

                    let factor = 0.1_f64;
                    let offset = 0_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end ChassisControl::BrakePressureBar public api

    /// ChassisControl::YawRateDps

    /// - Min: -500
    /// - Max: 500
    /// - Unit: "deg/s"
    /// - Receivers: LOGGER
    /// - Start bit: 24
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct YawRateDps {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl YawRateDps  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(YawRateDps {
                status: CanDataStatus::Unset,
                name:"YawRateDps",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < -500_f64 || 500_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-500..500]",value)));
            }
            let factor = 0.01_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            let value = u16::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[24..40].store_le(value);

            Ok(())
        }

    } // ChassisControl::YawRateDps impl end


    impl fmt::Display for YawRateDps {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("YawRateDps:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for YawRateDps {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("YawRateDps")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// ChassisControl::YawRateDps public api (CanDbcSignal trait)
    impl CanDbcSignal for YawRateDps {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[24..40].load_le::<u16>();

                    let value = i16::from_ne_bytes(value.to_ne_bytes());

                    let factor = 0.01_f64;
                    let offset = 0_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end ChassisControl::YawRateDps public api

    /// ChassisControl::LatAccelMps2

    /// - Min: -30
    /// - Max: 30
    /// - Unit: "m/s^2"
    /// - Receivers: LOGGER
    /// - Start bit: 40
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct LatAccelMps2 {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl LatAccelMps2  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(LatAccelMps2 {
                status: CanDataStatus::Unset,
                name:"LatAccelMps2",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < -30_f64 || 30_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-30..30]",value)));
            }
            let factor = 0.01_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            let value = u16::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[40..56].store_le(value);

            Ok(())
        }

    } // ChassisControl::LatAccelMps2 impl end


    impl fmt::Display for LatAccelMps2 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("LatAccelMps2:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for LatAccelMps2 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("LatAccelMps2")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// ChassisControl::LatAccelMps2 public api (CanDbcSignal trait)
    impl CanDbcSignal for LatAccelMps2 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[40..56].load_le::<u16>();

                    let value = i16::from_ne_bytes(value.to_ne_bytes());

                    let factor = 0.01_f64;
                    let offset = 0_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end ChassisControl::LatAccelMps2 public api

    /// ChassisControl::WheelFlKph

    /// - Min: 0
    /// - Max: 255
    /// - Unit: "km/h"
    /// - Receivers: LOGGER
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct WheelFlKph {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl WheelFlKph  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(WheelFlKph {
                status: CanDataStatus::Unset,
                name:"WheelFlKph",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[56..64].store_le(value);

            Ok(())
        }

    } // ChassisControl::WheelFlKph impl end


    impl fmt::Display for WheelFlKph {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("WheelFlKph:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for WheelFlKph {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("WheelFlKph")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// ChassisControl::WheelFlKph public api (CanDbcSignal trait)
    impl CanDbcSignal for WheelFlKph {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[56..64].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end ChassisControl::WheelFlKph public api


    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;6],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 210,
                name: "ChassisControl",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    AbsActive::new(),
                    EscActive::new(),
                    BrakePressureBar::new(),
                    YawRateDps::new(),
                    LatAccelMps2::new(),
                    WheelFlKph::new(),

                ],
            })))
        }


        pub fn set_values(&mut self, abs_active: bool, esc_active: bool, brake_pressure_bar: f64, yaw_rate_dps: f64, lat_accel_mps2: f64, wheel_fl_kph: u8, frame: &mut[u8]) -> Result<&mut Self, CanError> {


            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(abs_active), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error abs_active:Bool")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(esc_active), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error esc_active:Bool")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(brake_pressure_bar), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error brake_pressure_bar:F64")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(yaw_rate_dps), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error yaw_rate_dps:F64")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(lat_accel_mps2), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error lat_accel_mps2:F64")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(wheel_fl_kph), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error wheel_fl_kph:U8")),
            }

            Ok(self)
        }
    }


    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error abs_active:Bool")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error esc_active:Bool")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error brake_pressure_bar:F64")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error yaw_rate_dps:F64")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error lat_accel_mps2:F64")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error wheel_fl_kph:U8")),
            }

        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error abs_active:Bool")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error esc_active:Bool")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error brake_pressure_bar:F64")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error yaw_rate_dps:F64")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error lat_accel_mps2:F64")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error wheel_fl_kph:U8")),
            }

            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end ChassisControl impl for CanDbcMessage

} // end ChassisControl message


/// Diag_FD_Frame Message
/// - ID: 300 (0x12c)
/// - Size: 64 bytes
/// - Transmitter: DIAG_TOOL
///
/// CAN FD diagnostics transport sample frame (64 bytes).

pub mod DiagFdFrame { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        DiagServiceId,
        DiagSubfunction,
        DiagStatus,
        PayloadLen,
        PayloadByte0,
        PayloadByte1,
        PayloadByte2,
        PayloadByte3,
        PayloadByte4,
        PayloadByte5,
        PayloadByte6,
        PayloadByte7,
        PayloadByte8,
        PayloadByte9,
        PayloadByte10,
        PayloadByte11,
        PayloadByte12,
        PayloadByte13,
        PayloadByte14,
        PayloadByte15,

    }

    /// DiagFdFrame::DiagServiceId

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DiagServiceId {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl DiagServiceId  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DiagServiceId {
                status: CanDataStatus::Unset,
                name:"DiagServiceId",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[0..8].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::DiagServiceId impl end


    impl fmt::Display for DiagServiceId {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DiagServiceId:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DiagServiceId {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DiagServiceId")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::DiagServiceId public api (CanDbcSignal trait)
    impl CanDbcSignal for DiagServiceId {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[0..8].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::DiagServiceId public api

    /// DiagFdFrame::DiagSubfunction

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DiagSubfunction {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl DiagSubfunction  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DiagSubfunction {
                status: CanDataStatus::Unset,
                name:"DiagSubfunction",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[8..16].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::DiagSubfunction impl end


    impl fmt::Display for DiagSubfunction {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DiagSubfunction:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DiagSubfunction {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DiagSubfunction")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::DiagSubfunction public api (CanDbcSignal trait)
    impl CanDbcSignal for DiagSubfunction {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[8..16].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::DiagSubfunction public api

    /// DiagFdFrame::DiagStatus

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DiagStatus {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl DiagStatus  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DiagStatus {
                status: CanDataStatus::Unset,
                name:"DiagStatus",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[16..24].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::DiagStatus impl end


    impl fmt::Display for DiagStatus {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DiagStatus:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DiagStatus {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DiagStatus")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::DiagStatus public api (CanDbcSignal trait)
    impl CanDbcSignal for DiagStatus {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[16..24].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::DiagStatus public api

    /// DiagFdFrame::PayloadLen

    /// - Min: 0
    /// - Max: 64
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct PayloadLen {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl PayloadLen  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PayloadLen {
                status: CanDataStatus::Unset,
                name:"PayloadLen",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[24..32].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::PayloadLen impl end


    impl fmt::Display for PayloadLen {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PayloadLen:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PayloadLen {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PayloadLen")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::PayloadLen public api (CanDbcSignal trait)
    impl CanDbcSignal for PayloadLen {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[24..32].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::PayloadLen public api

    /// DiagFdFrame::PayloadByte0

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct PayloadByte0 {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl PayloadByte0  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PayloadByte0 {
                status: CanDataStatus::Unset,
                name:"PayloadByte0",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[32..40].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::PayloadByte0 impl end


    impl fmt::Display for PayloadByte0 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PayloadByte0:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PayloadByte0 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PayloadByte0")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::PayloadByte0 public api (CanDbcSignal trait)
    impl CanDbcSignal for PayloadByte0 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[32..40].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::PayloadByte0 public api

    /// DiagFdFrame::PayloadByte1

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct PayloadByte1 {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl PayloadByte1  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PayloadByte1 {
                status: CanDataStatus::Unset,
                name:"PayloadByte1",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[40..48].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::PayloadByte1 impl end


    impl fmt::Display for PayloadByte1 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PayloadByte1:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PayloadByte1 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PayloadByte1")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::PayloadByte1 public api (CanDbcSignal trait)
    impl CanDbcSignal for PayloadByte1 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[40..48].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::PayloadByte1 public api

    /// DiagFdFrame::PayloadByte2

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct PayloadByte2 {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl PayloadByte2  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PayloadByte2 {
                status: CanDataStatus::Unset,
                name:"PayloadByte2",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[48..56].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::PayloadByte2 impl end


    impl fmt::Display for PayloadByte2 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PayloadByte2:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PayloadByte2 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PayloadByte2")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::PayloadByte2 public api (CanDbcSignal trait)
    impl CanDbcSignal for PayloadByte2 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[48..56].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::PayloadByte2 public api

    /// DiagFdFrame::PayloadByte3

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct PayloadByte3 {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl PayloadByte3  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PayloadByte3 {
                status: CanDataStatus::Unset,
                name:"PayloadByte3",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[56..64].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::PayloadByte3 impl end


    impl fmt::Display for PayloadByte3 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PayloadByte3:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PayloadByte3 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PayloadByte3")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::PayloadByte3 public api (CanDbcSignal trait)
    impl CanDbcSignal for PayloadByte3 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[56..64].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::PayloadByte3 public api

    /// DiagFdFrame::PayloadByte4

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 64
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct PayloadByte4 {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl PayloadByte4  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PayloadByte4 {
                status: CanDataStatus::Unset,
                name:"PayloadByte4",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[64..72].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::PayloadByte4 impl end


    impl fmt::Display for PayloadByte4 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PayloadByte4:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PayloadByte4 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PayloadByte4")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::PayloadByte4 public api (CanDbcSignal trait)
    impl CanDbcSignal for PayloadByte4 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[64..72].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::PayloadByte4 public api

    /// DiagFdFrame::PayloadByte5

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 72
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct PayloadByte5 {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl PayloadByte5  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PayloadByte5 {
                status: CanDataStatus::Unset,
                name:"PayloadByte5",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[72..80].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::PayloadByte5 impl end


    impl fmt::Display for PayloadByte5 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PayloadByte5:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PayloadByte5 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PayloadByte5")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::PayloadByte5 public api (CanDbcSignal trait)
    impl CanDbcSignal for PayloadByte5 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[72..80].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::PayloadByte5 public api

    /// DiagFdFrame::PayloadByte6

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 80
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct PayloadByte6 {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl PayloadByte6  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PayloadByte6 {
                status: CanDataStatus::Unset,
                name:"PayloadByte6",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[80..88].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::PayloadByte6 impl end


    impl fmt::Display for PayloadByte6 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PayloadByte6:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PayloadByte6 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PayloadByte6")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::PayloadByte6 public api (CanDbcSignal trait)
    impl CanDbcSignal for PayloadByte6 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[80..88].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::PayloadByte6 public api

    /// DiagFdFrame::PayloadByte7

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 88
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct PayloadByte7 {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl PayloadByte7  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PayloadByte7 {
                status: CanDataStatus::Unset,
                name:"PayloadByte7",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[88..96].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::PayloadByte7 impl end


    impl fmt::Display for PayloadByte7 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PayloadByte7:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PayloadByte7 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PayloadByte7")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::PayloadByte7 public api (CanDbcSignal trait)
    impl CanDbcSignal for PayloadByte7 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[88..96].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::PayloadByte7 public api

    /// DiagFdFrame::PayloadByte8

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 96
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct PayloadByte8 {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl PayloadByte8  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PayloadByte8 {
                status: CanDataStatus::Unset,
                name:"PayloadByte8",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[96..104].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::PayloadByte8 impl end


    impl fmt::Display for PayloadByte8 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PayloadByte8:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PayloadByte8 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PayloadByte8")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::PayloadByte8 public api (CanDbcSignal trait)
    impl CanDbcSignal for PayloadByte8 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[96..104].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::PayloadByte8 public api

    /// DiagFdFrame::PayloadByte9

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 104
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct PayloadByte9 {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl PayloadByte9  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PayloadByte9 {
                status: CanDataStatus::Unset,
                name:"PayloadByte9",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[104..112].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::PayloadByte9 impl end


    impl fmt::Display for PayloadByte9 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PayloadByte9:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PayloadByte9 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PayloadByte9")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::PayloadByte9 public api (CanDbcSignal trait)
    impl CanDbcSignal for PayloadByte9 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[104..112].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::PayloadByte9 public api

    /// DiagFdFrame::PayloadByte10

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 112
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct PayloadByte10 {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl PayloadByte10  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PayloadByte10 {
                status: CanDataStatus::Unset,
                name:"PayloadByte10",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[112..120].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::PayloadByte10 impl end


    impl fmt::Display for PayloadByte10 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PayloadByte10:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PayloadByte10 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PayloadByte10")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::PayloadByte10 public api (CanDbcSignal trait)
    impl CanDbcSignal for PayloadByte10 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[112..120].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::PayloadByte10 public api

    /// DiagFdFrame::PayloadByte11

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 120
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct PayloadByte11 {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl PayloadByte11  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PayloadByte11 {
                status: CanDataStatus::Unset,
                name:"PayloadByte11",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[120..128].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::PayloadByte11 impl end


    impl fmt::Display for PayloadByte11 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PayloadByte11:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PayloadByte11 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PayloadByte11")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::PayloadByte11 public api (CanDbcSignal trait)
    impl CanDbcSignal for PayloadByte11 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[120..128].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::PayloadByte11 public api

    /// DiagFdFrame::PayloadByte12

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 128
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct PayloadByte12 {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl PayloadByte12  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PayloadByte12 {
                status: CanDataStatus::Unset,
                name:"PayloadByte12",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[128..136].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::PayloadByte12 impl end


    impl fmt::Display for PayloadByte12 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PayloadByte12:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PayloadByte12 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PayloadByte12")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::PayloadByte12 public api (CanDbcSignal trait)
    impl CanDbcSignal for PayloadByte12 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[128..136].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::PayloadByte12 public api

    /// DiagFdFrame::PayloadByte13

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 136
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct PayloadByte13 {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl PayloadByte13  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PayloadByte13 {
                status: CanDataStatus::Unset,
                name:"PayloadByte13",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[136..144].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::PayloadByte13 impl end


    impl fmt::Display for PayloadByte13 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PayloadByte13:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PayloadByte13 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PayloadByte13")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::PayloadByte13 public api (CanDbcSignal trait)
    impl CanDbcSignal for PayloadByte13 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[136..144].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::PayloadByte13 public api

    /// DiagFdFrame::PayloadByte14

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 144
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct PayloadByte14 {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl PayloadByte14  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PayloadByte14 {
                status: CanDataStatus::Unset,
                name:"PayloadByte14",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[144..152].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::PayloadByte14 impl end


    impl fmt::Display for PayloadByte14 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PayloadByte14:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PayloadByte14 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PayloadByte14")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::PayloadByte14 public api (CanDbcSignal trait)
    impl CanDbcSignal for PayloadByte14 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[144..152].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::PayloadByte14 public api

    /// DiagFdFrame::PayloadByte15

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 152
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct PayloadByte15 {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl PayloadByte15  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(PayloadByte15 {
                status: CanDataStatus::Unset,
                name:"PayloadByte15",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[152..160].store_le(value);

            Ok(())
        }

    } // DiagFdFrame::PayloadByte15 impl end


    impl fmt::Display for PayloadByte15 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("PayloadByte15:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for PayloadByte15 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("PayloadByte15")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DiagFdFrame::PayloadByte15 public api (CanDbcSignal trait)
    impl CanDbcSignal for PayloadByte15 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[152..160].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DiagFdFrame::PayloadByte15 public api


    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;20],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 300,
                name: "DiagFdFrame",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    DiagServiceId::new(),
                    DiagSubfunction::new(),
                    DiagStatus::new(),
                    PayloadLen::new(),
                    PayloadByte0::new(),
                    PayloadByte1::new(),
                    PayloadByte2::new(),
                    PayloadByte3::new(),
                    PayloadByte4::new(),
                    PayloadByte5::new(),
                    PayloadByte6::new(),
                    PayloadByte7::new(),
                    PayloadByte8::new(),
                    PayloadByte9::new(),
                    PayloadByte10::new(),
                    PayloadByte11::new(),
                    PayloadByte12::new(),
                    PayloadByte13::new(),
                    PayloadByte14::new(),
                    PayloadByte15::new(),

                ],
            })))
        }


        pub fn set_values(&mut self, diag_service_id: u8, diag_subfunction: u8, diag_status: u8, payload_len: u8, payload_byte0: u8, payload_byte1: u8, payload_byte2: u8, payload_byte3: u8, payload_byte4: u8, payload_byte5: u8, payload_byte6: u8, payload_byte7: u8, payload_byte8: u8, payload_byte9: u8, payload_byte10: u8, payload_byte11: u8, payload_byte12: u8, payload_byte13: u8, payload_byte14: u8, payload_byte15: u8, frame: &mut[u8]) -> Result<&mut Self, CanError> {


            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(diag_service_id), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error diag_service_id:U8")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(diag_subfunction), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error diag_subfunction:U8")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(diag_status), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error diag_status:U8")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(payload_len), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error payload_len:U8")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(payload_byte0), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error payload_byte0:U8")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(payload_byte1), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error payload_byte1:U8")),
            }

            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(payload_byte2), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error payload_byte2:U8")),
            }

            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(payload_byte3), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error payload_byte3:U8")),
            }

            match Rc::clone (&self.signals[8]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(payload_byte4), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error payload_byte4:U8")),
            }

            match Rc::clone (&self.signals[9]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(payload_byte5), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error payload_byte5:U8")),
            }

            match Rc::clone (&self.signals[10]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(payload_byte6), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error payload_byte6:U8")),
            }

            match Rc::clone (&self.signals[11]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(payload_byte7), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error payload_byte7:U8")),
            }

            match Rc::clone (&self.signals[12]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(payload_byte8), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error payload_byte8:U8")),
            }

            match Rc::clone (&self.signals[13]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(payload_byte9), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error payload_byte9:U8")),
            }

            match Rc::clone (&self.signals[14]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(payload_byte10), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error payload_byte10:U8")),
            }

            match Rc::clone (&self.signals[15]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(payload_byte11), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error payload_byte11:U8")),
            }

            match Rc::clone (&self.signals[16]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(payload_byte12), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error payload_byte12:U8")),
            }

            match Rc::clone (&self.signals[17]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(payload_byte13), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error payload_byte13:U8")),
            }

            match Rc::clone (&self.signals[18]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(payload_byte14), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error payload_byte14:U8")),
            }

            match Rc::clone (&self.signals[19]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(payload_byte15), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error payload_byte15:U8")),
            }

            Ok(self)
        }
    }


    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error diag_service_id:U8")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error diag_subfunction:U8")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error diag_status:U8")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error payload_len:U8")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error payload_byte0:U8")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error payload_byte1:U8")),
            }

            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error payload_byte2:U8")),
            }

            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error payload_byte3:U8")),
            }

            match Rc::clone (&self.signals[8]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error payload_byte4:U8")),
            }

            match Rc::clone (&self.signals[9]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error payload_byte5:U8")),
            }

            match Rc::clone (&self.signals[10]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error payload_byte6:U8")),
            }

            match Rc::clone (&self.signals[11]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error payload_byte7:U8")),
            }

            match Rc::clone (&self.signals[12]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error payload_byte8:U8")),
            }

            match Rc::clone (&self.signals[13]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error payload_byte9:U8")),
            }

            match Rc::clone (&self.signals[14]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error payload_byte10:U8")),
            }

            match Rc::clone (&self.signals[15]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error payload_byte11:U8")),
            }

            match Rc::clone (&self.signals[16]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error payload_byte12:U8")),
            }

            match Rc::clone (&self.signals[17]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error payload_byte13:U8")),
            }

            match Rc::clone (&self.signals[18]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error payload_byte14:U8")),
            }

            match Rc::clone (&self.signals[19]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error payload_byte15:U8")),
            }

        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error diag_service_id:U8")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error diag_subfunction:U8")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error diag_status:U8")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error payload_len:U8")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error payload_byte0:U8")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error payload_byte1:U8")),
            }

            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error payload_byte2:U8")),
            }

            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error payload_byte3:U8")),
            }

            match Rc::clone (&self.signals[8]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error payload_byte4:U8")),
            }

            match Rc::clone (&self.signals[9]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error payload_byte5:U8")),
            }

            match Rc::clone (&self.signals[10]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error payload_byte6:U8")),
            }

            match Rc::clone (&self.signals[11]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error payload_byte7:U8")),
            }

            match Rc::clone (&self.signals[12]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error payload_byte8:U8")),
            }

            match Rc::clone (&self.signals[13]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error payload_byte9:U8")),
            }

            match Rc::clone (&self.signals[14]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error payload_byte10:U8")),
            }

            match Rc::clone (&self.signals[15]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error payload_byte11:U8")),
            }

            match Rc::clone (&self.signals[16]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error payload_byte12:U8")),
            }

            match Rc::clone (&self.signals[17]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error payload_byte13:U8")),
            }

            match Rc::clone (&self.signals[18]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error payload_byte14:U8")),
            }

            match Rc::clone (&self.signals[19]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error payload_byte15:U8")),
            }

            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end DiagFdFrame impl for CanDbcMessage

} // end DiagFdFrame message


/// MUX_TEST Message
/// - ID: 322 (0x142)
/// - Size: 8 bytes
/// - Transmitter: POWERTRAIN_CTRL
///
/// Minimal multiplexing test message. MUX_signal selects pages. Page 0: open/closed/direction/mode. Page 1: speed/temperature. Collisions between pages are intentional, but signals inside the same page do not overlap (cantools requirement).

pub mod MuxTest { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        MuxSignal,
        Open,
        Closed,
        Direction,
        Mode,
        Speed,
        Temperature,

    }

    /// MuxTest::MuxSignal
    ///
    /// Multiplexer: 0=STATE, 1=MEASURE, 2=INVALID.

    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct MuxSignal {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }

    // DBC definition for MsgID:322 Signal:MUX_signal
    #[derive(Serialize, Deserialize)]
    pub enum DbcMuxSignal {
        State,
        Measure,
        Invalid,

        _Other(u8),
    }

    impl From<DbcMuxSignal> for u8 {
        fn from (val: DbcMuxSignal) -> u8 {
            match val {
                DbcMuxSignal::State => 0_u8,
                DbcMuxSignal::Measure => 1_u8,
                DbcMuxSignal::Invalid => 2_u8,

                DbcMuxSignal::_Other(x) => x
            }
        }
    }


    impl MuxSignal  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(MuxSignal {
                status: CanDataStatus::Unset,
                name:"MuxSignal",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }
        pub fn get_as_def (&self) -> DbcMuxSignal {
            match self.get_typed_value() {
                0_u8 => DbcMuxSignal::State,
                1_u8 => DbcMuxSignal::Measure,
                2_u8 => DbcMuxSignal::Invalid,
                _ => DbcMuxSignal::_Other(self.get_typed_value()),
            }

        }
        pub fn set_raw_value(&mut self, value: u8, data: &mut[u8]) {
            data.view_bits_mut::<Lsb0>()[0..2].store_le(value);

        }
        pub fn set_as_def (&mut self, signal_def: DbcMuxSignal, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcMuxSignal::State => Ok(self.set_raw_value(0, data)),
                DbcMuxSignal::Measure => Ok(self.set_raw_value(1, data)),
                DbcMuxSignal::Invalid => Ok(self.set_raw_value(2, data)),
                DbcMuxSignal::_Other(x) => self.set_typed_value(x,data)
            }
        }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[0..2].store_le(value);

            Ok(())
        }

    } // MuxTest::MuxSignal impl end


    impl fmt::Display for MuxSignal {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("MuxSignal:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for MuxSignal {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("MuxSignal")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// MuxTest::MuxSignal public api (CanDbcSignal trait)
    impl CanDbcSignal for MuxSignal {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[0..2].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MuxTest::MuxSignal public api

    /// MuxTest::Open
    ///
    /// STATE page (MUX_signal=0). Collides with MEASURE speed bits.

    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct Open {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<bool>,
    }

    // DBC definition for MsgID:322 Signal:open
    #[derive(Serialize, Deserialize)]
    pub enum DbcOpen {
        No,
        Yes,

        _Other(bool),
    }

    impl From<DbcOpen> for bool {
        fn from (val: DbcOpen) -> bool {
            match val {
                DbcOpen::No => false,
                DbcOpen::Yes => true,

                DbcOpen::_Other(x) => x
            }
        }
    }


    impl Open  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Open {
                status: CanDataStatus::Unset,
                name:"Open",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }
        pub fn get_as_def (&self) -> DbcOpen {
            match self.get_typed_value() {
                false => DbcOpen::No,
                true => DbcOpen::Yes,
            }

        }
        pub fn set_raw_value(&mut self, value: u8, data: &mut[u8]) {
            data.view_bits_mut::<Lsb0>()[3..4].store_le(value);

        }
        pub fn set_as_def (&mut self, signal_def: DbcOpen, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcOpen::No => Ok(self.set_raw_value(0, data)),
                DbcOpen::Yes => Ok(self.set_raw_value(1, data)),
                DbcOpen::_Other(x) => self.set_typed_value(x,data)
            }
        }

        fn get_typed_value(&self) -> bool {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Lsb0>()[3..4].store_le(value);

            Ok(())
        }

    } // MuxTest::Open impl end


    impl fmt::Display for Open {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Open:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Open {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Open")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// MuxTest::Open public api (CanDbcSignal trait)
    impl CanDbcSignal for Open {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[3..4].load_le::<u8>();

                    let newval = value == 1;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                    };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                        self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MuxTest::Open public api

    /// MuxTest::Closed
    ///
    /// STATE page (MUX_signal=0). Collides with MEASURE speed bits.

    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct Closed {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<bool>,
    }

    // DBC definition for MsgID:322 Signal:closed
    #[derive(Serialize, Deserialize)]
    pub enum DbcClosed {
        No,
        Yes,

        _Other(bool),
    }

    impl From<DbcClosed> for bool {
        fn from (val: DbcClosed) -> bool {
            match val {
                DbcClosed::No => false,
                DbcClosed::Yes => true,

                DbcClosed::_Other(x) => x
            }
        }
    }


    impl Closed  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Closed {
                status: CanDataStatus::Unset,
                name:"Closed",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }
        pub fn get_as_def (&self) -> DbcClosed {
            match self.get_typed_value() {
                false => DbcClosed::No,
                true => DbcClosed::Yes,
            }

        }
        pub fn set_raw_value(&mut self, value: u8, data: &mut[u8]) {
            data.view_bits_mut::<Lsb0>()[4..5].store_le(value);

        }
        pub fn set_as_def (&mut self, signal_def: DbcClosed, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcClosed::No => Ok(self.set_raw_value(0, data)),
                DbcClosed::Yes => Ok(self.set_raw_value(1, data)),
                DbcClosed::_Other(x) => self.set_typed_value(x,data)
            }
        }

        fn get_typed_value(&self) -> bool {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Lsb0>()[4..5].store_le(value);

            Ok(())
        }

    } // MuxTest::Closed impl end


    impl fmt::Display for Closed {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Closed:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Closed {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Closed")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// MuxTest::Closed public api (CanDbcSignal trait)
    impl CanDbcSignal for Closed {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[4..5].load_le::<u8>();

                    let newval = value == 1;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                    };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                        self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MuxTest::Closed public api

    /// MuxTest::Direction
    ///
    /// STATE page (MUX_signal=0). Collides with MEASURE speed bits.

    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 5
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct Direction {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }

    // DBC definition for MsgID:322 Signal:direction
    #[derive(Serialize, Deserialize)]
    pub enum DbcDirection {
        Stop,
        Opening,
        Closing,
        Unknown,

        _Other(u8),
    }

    impl From<DbcDirection> for u8 {
        fn from (val: DbcDirection) -> u8 {
            match val {
                DbcDirection::Stop => 0_u8,
                DbcDirection::Opening => 1_u8,
                DbcDirection::Closing => 2_u8,
                DbcDirection::Unknown => 3_u8,

                DbcDirection::_Other(x) => x
            }
        }
    }


    impl Direction  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Direction {
                status: CanDataStatus::Unset,
                name:"Direction",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }
        pub fn get_as_def (&self) -> DbcDirection {
            match self.get_typed_value() {
                0_u8 => DbcDirection::Stop,
                1_u8 => DbcDirection::Opening,
                2_u8 => DbcDirection::Closing,
                3_u8 => DbcDirection::Unknown,
                _ => DbcDirection::_Other(self.get_typed_value()),
            }

        }
        pub fn set_raw_value(&mut self, value: u8, data: &mut[u8]) {
            data.view_bits_mut::<Lsb0>()[5..7].store_le(value);

        }
        pub fn set_as_def (&mut self, signal_def: DbcDirection, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcDirection::Stop => Ok(self.set_raw_value(0, data)),
                DbcDirection::Opening => Ok(self.set_raw_value(1, data)),
                DbcDirection::Closing => Ok(self.set_raw_value(2, data)),
                DbcDirection::Unknown => Ok(self.set_raw_value(3, data)),
                DbcDirection::_Other(x) => self.set_typed_value(x,data)
            }
        }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[5..7].store_le(value);

            Ok(())
        }

    } // MuxTest::Direction impl end


    impl fmt::Display for Direction {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Direction:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Direction {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Direction")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// MuxTest::Direction public api (CanDbcSignal trait)
    impl CanDbcSignal for Direction {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[5..7].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MuxTest::Direction public api

    /// MuxTest::Mode
    ///
    /// STATE page (MUX_signal=0). Test mode at bits 61..63.

    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 61
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct Mode {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }

    // DBC definition for MsgID:322 Signal:mode
    #[derive(Serialize, Deserialize)]
    pub enum DbcMode {
        M0,
        M1,
        M2,
        M3,
        M4,
        M5,
        M6,
        M7,

        _Other(u8),
    }

    impl From<DbcMode> for u8 {
        fn from (val: DbcMode) -> u8 {
            match val {
                DbcMode::M0 => 0_u8,
                DbcMode::M1 => 1_u8,
                DbcMode::M2 => 2_u8,
                DbcMode::M3 => 3_u8,
                DbcMode::M4 => 4_u8,
                DbcMode::M5 => 5_u8,
                DbcMode::M6 => 6_u8,
                DbcMode::M7 => 7_u8,

                DbcMode::_Other(x) => x
            }
        }
    }


    impl Mode  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Mode {
                status: CanDataStatus::Unset,
                name:"Mode",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }
        pub fn get_as_def (&self) -> DbcMode {
            match self.get_typed_value() {
                0_u8 => DbcMode::M0,
                1_u8 => DbcMode::M1,
                2_u8 => DbcMode::M2,
                3_u8 => DbcMode::M3,
                4_u8 => DbcMode::M4,
                5_u8 => DbcMode::M5,
                6_u8 => DbcMode::M6,
                7_u8 => DbcMode::M7,
                _ => DbcMode::_Other(self.get_typed_value()),
            }

        }
        pub fn set_raw_value(&mut self, value: u8, data: &mut[u8]) {
            data.view_bits_mut::<Lsb0>()[61..64].store_le(value);

        }
        pub fn set_as_def (&mut self, signal_def: DbcMode, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcMode::M0 => Ok(self.set_raw_value(0, data)),
                DbcMode::M1 => Ok(self.set_raw_value(1, data)),
                DbcMode::M2 => Ok(self.set_raw_value(2, data)),
                DbcMode::M3 => Ok(self.set_raw_value(3, data)),
                DbcMode::M4 => Ok(self.set_raw_value(4, data)),
                DbcMode::M5 => Ok(self.set_raw_value(5, data)),
                DbcMode::M6 => Ok(self.set_raw_value(6, data)),
                DbcMode::M7 => Ok(self.set_raw_value(7, data)),
                DbcMode::_Other(x) => self.set_typed_value(x,data)
            }
        }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[61..64].store_le(value);

            Ok(())
        }

    } // MuxTest::Mode impl end


    impl fmt::Display for Mode {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Mode:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Mode {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Mode")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// MuxTest::Mode public api (CanDbcSignal trait)
    impl CanDbcSignal for Mode {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[61..64].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MuxTest::Mode public api

    /// MuxTest::Speed
    ///
    /// MEASURE page (MUX_signal=1). Signed 10-bit, factor 0.1 m/s. Overlaps STATE page bits starting at bit 3.

    /// - Min: -51.2
    /// - Max: 51.1
    /// - Unit: "m/s"
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 3
    /// - Signal size: 10 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct Speed {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl Speed  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Speed {
                status: CanDataStatus::Unset,
                name:"Speed",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < -51.2_f64 || 51.1_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-51.2..51.1]",value)));
            }
            let factor = 0.1_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            let value = u16::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[3..13].store_le(value);

            Ok(())
        }

    } // MuxTest::Speed impl end


    impl fmt::Display for Speed {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Speed:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Speed {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Speed")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// MuxTest::Speed public api (CanDbcSignal trait)
    impl CanDbcSignal for Speed {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[3..13].load_le::<u16>();

                    let value = i16::from_ne_bytes(value.to_ne_bytes());

                    let factor = 0.1_f64;
                    let offset = 0_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MuxTest::Speed public api

    /// MuxTest::Temperature
    ///
    /// MEASURE page (MUX_signal=1). Signed 8-bit degC. Located at bit 13 to avoid overlap with speed.

    /// - Min: -128
    /// - Max: 127
    /// - Unit: "degC"
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 13
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct Temperature {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<i8>,
    }


    impl Temperature  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Temperature {
                status: CanDataStatus::Unset,
                name:"Temperature",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> i8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:i8, data:&mut [u8]) -> Result<(),CanError> {
            let value = u8::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[13..21].store_le(value);

            Ok(())
        }

    } // MuxTest::Temperature impl end


    impl fmt::Display for Temperature {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Temperature:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Temperature {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Temperature")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// MuxTest::Temperature public api (CanDbcSignal trait)
    impl CanDbcSignal for Temperature {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[13..21].load_le::<u8>();

                    let value = i8::from_ne_bytes(value.to_ne_bytes());

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:i8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::I8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MuxTest::Temperature public api


    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;7],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 322,
                name: "MuxTest",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    MuxSignal::new(),
                    Open::new(),
                    Closed::new(),
                    Direction::new(),
                    Mode::new(),
                    Speed::new(),
                    Temperature::new(),

                ],
            })))
        }


        pub fn set_values(&mut self, mux_signal: u8, open: bool, closed: bool, direction: u8, mode: u8, speed: f64, temperature: i8, frame: &mut[u8]) -> Result<&mut Self, CanError> {


            let __mux_raw_value: u64 = mux_signal as u64;
            println!("RLM __mux_raw_value{}",__mux_raw_value);

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(mux_signal), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error mux_signal:U8")),
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[1]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::Bool(open), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error open:Bool")),
                }
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[2]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::Bool(closed), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error closed:Bool")),
                }
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[3]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::U8(direction), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error direction:U8")),
                }
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[4]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::U8(mode), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error mode:U8")),
                }
            }

            if __mux_raw_value == 1 {
                match Rc::clone (&self.signals[5]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::F64(speed), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error speed:F64")),
                }
            }

            if __mux_raw_value == 1 {
                match Rc::clone (&self.signals[6]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::I8(temperature), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error temperature:I8")),
                }
            }

            Ok(self)
        }
    }


    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error mux_signal:U8")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error open:Bool")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error closed:Bool")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error direction:U8")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error mode:U8")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error speed:F64")),
            }

            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error temperature:I8")),
            }

        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;

            let __mux_raw_value: u64 = (frame.data.view_bits::<Lsb0>()[0..2].load_le::<u8>()) as u64;

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error mux_signal:U8")),
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[1]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error open:Bool")),
                }
            } else {
                match Rc::clone (&self.signals[1]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error open:Bool")),
                }
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[2]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error closed:Bool")),
                }
            } else {
                match Rc::clone (&self.signals[2]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error closed:Bool")),
                }
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[3]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error direction:U8")),
                }
            } else {
                match Rc::clone (&self.signals[3]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error direction:U8")),
                }
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[4]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error mode:U8")),
                }
            } else {
                match Rc::clone (&self.signals[4]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error mode:U8")),
                }
            }

            if __mux_raw_value == 1 {
                match Rc::clone (&self.signals[5]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error speed:F64")),
                }
            } else {
                match Rc::clone (&self.signals[5]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error speed:F64")),
                }
            }

            if __mux_raw_value == 1 {
                match Rc::clone (&self.signals[6]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error temperature:I8")),
                }
            } else {
                match Rc::clone (&self.signals[6]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error temperature:I8")),
                }
            }

            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end MuxTest impl for CanDbcMessage

} // end MuxTest message


/// DataTypes_LE Message
/// - ID: 400 (0x190)
/// - Size: 64 bytes
/// - Transmitter: SENSOR_GATEWAY
///
/// Little-endian type coverage frame (includes 64-bit signed/unsigned).

pub mod DataTypesLe { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        FlagReadyBool,
        U8Counter,
        I8TempRaw,
        U16OdometerDm,
        I16TorqueRaw,
        U32TripM,
        I32EnergyMWh,
        U64TimestampMs,
        I64BalanceNA,

    }

    /// DataTypesLe::FlagReadyBool

    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct FlagReadyBool {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<bool>,
    }

    // DBC definition for MsgID:400 Signal:flag_ready_bool
    #[derive(Serialize, Deserialize)]
    pub enum DbcFlagReadyBool {
        No,
        Yes,

        _Other(bool),
    }

    impl From<DbcFlagReadyBool> for bool {
        fn from (val: DbcFlagReadyBool) -> bool {
            match val {
                DbcFlagReadyBool::No => false,
                DbcFlagReadyBool::Yes => true,

                DbcFlagReadyBool::_Other(x) => x
            }
        }
    }


    impl FlagReadyBool  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(FlagReadyBool {
                status: CanDataStatus::Unset,
                name:"FlagReadyBool",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }
        pub fn get_as_def (&self) -> DbcFlagReadyBool {
            match self.get_typed_value() {
                false => DbcFlagReadyBool::No,
                true => DbcFlagReadyBool::Yes,
            }

        }
        pub fn set_raw_value(&mut self, value: u8, data: &mut[u8]) {
            data.view_bits_mut::<Lsb0>()[0..1].store_le(value);

        }
        pub fn set_as_def (&mut self, signal_def: DbcFlagReadyBool, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcFlagReadyBool::No => Ok(self.set_raw_value(0, data)),
                DbcFlagReadyBool::Yes => Ok(self.set_raw_value(1, data)),
                DbcFlagReadyBool::_Other(x) => self.set_typed_value(x,data)
            }
        }

        fn get_typed_value(&self) -> bool {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Lsb0>()[0..1].store_le(value);

            Ok(())
        }

    } // DataTypesLe::FlagReadyBool impl end


    impl fmt::Display for FlagReadyBool {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("FlagReadyBool:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for FlagReadyBool {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("FlagReadyBool")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DataTypesLe::FlagReadyBool public api (CanDbcSignal trait)
    impl CanDbcSignal for FlagReadyBool {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[0..1].load_le::<u8>();

                    let newval = value == 1;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                    };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                        self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DataTypesLe::FlagReadyBool public api

    /// DataTypesLe::U8Counter

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct U8Counter {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl U8Counter  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(U8Counter {
                status: CanDataStatus::Unset,
                name:"U8Counter",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[8..16].store_le(value);

            Ok(())
        }

    } // DataTypesLe::U8Counter impl end


    impl fmt::Display for U8Counter {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("U8Counter:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for U8Counter {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("U8Counter")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DataTypesLe::U8Counter public api (CanDbcSignal trait)
    impl CanDbcSignal for U8Counter {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[8..16].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DataTypesLe::U8Counter public api

    /// DataTypesLe::I8TempRaw

    /// - Min: -128
    /// - Max: 127
    /// - Unit: "raw"
    /// - Receivers: LOGGER
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct I8TempRaw {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<i8>,
    }


    impl I8TempRaw  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(I8TempRaw {
                status: CanDataStatus::Unset,
                name:"I8TempRaw",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> i8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:i8, data:&mut [u8]) -> Result<(),CanError> {
            let value = u8::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[16..24].store_le(value);

            Ok(())
        }

    } // DataTypesLe::I8TempRaw impl end


    impl fmt::Display for I8TempRaw {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("I8TempRaw:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for I8TempRaw {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("I8TempRaw")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DataTypesLe::I8TempRaw public api (CanDbcSignal trait)
    impl CanDbcSignal for I8TempRaw {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[16..24].load_le::<u8>();

                    let value = i8::from_ne_bytes(value.to_ne_bytes());

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:i8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::I8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DataTypesLe::I8TempRaw public api

    /// DataTypesLe::U16OdometerDm

    /// - Min: 0
    /// - Max: 65535
    /// - Unit: "dm"
    /// - Receivers: LOGGER
    /// - Start bit: 24
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct U16OdometerDm {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u16>,
    }


    impl U16OdometerDm  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(U16OdometerDm {
                status: CanDataStatus::Unset,
                name:"U16OdometerDm",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u16 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[24..40].store_le(value);

            Ok(())
        }

    } // DataTypesLe::U16OdometerDm impl end


    impl fmt::Display for U16OdometerDm {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("U16OdometerDm:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for U16OdometerDm {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("U16OdometerDm")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DataTypesLe::U16OdometerDm public api (CanDbcSignal trait)
    impl CanDbcSignal for U16OdometerDm {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[24..40].load_le::<u16>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DataTypesLe::U16OdometerDm public api

    /// DataTypesLe::I16TorqueRaw

    /// - Min: -32768
    /// - Max: 32767
    /// - Unit: "raw"
    /// - Receivers: LOGGER
    /// - Start bit: 40
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct I16TorqueRaw {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<i16>,
    }


    impl I16TorqueRaw  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(I16TorqueRaw {
                status: CanDataStatus::Unset,
                name:"I16TorqueRaw",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> i16 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:i16, data:&mut [u8]) -> Result<(),CanError> {
            let value = u16::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[40..56].store_le(value);

            Ok(())
        }

    } // DataTypesLe::I16TorqueRaw impl end


    impl fmt::Display for I16TorqueRaw {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("I16TorqueRaw:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for I16TorqueRaw {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("I16TorqueRaw")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DataTypesLe::I16TorqueRaw public api (CanDbcSignal trait)
    impl CanDbcSignal for I16TorqueRaw {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[40..56].load_le::<u16>();

                    let value = i16::from_ne_bytes(value.to_ne_bytes());

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:i16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::I16(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DataTypesLe::I16TorqueRaw public api

    /// DataTypesLe::U32TripM

    /// - Min: 0
    /// - Max: 4294967295
    /// - Unit: "m"
    /// - Receivers: LOGGER
    /// - Start bit: 56
    /// - Signal size: 32 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct U32TripM {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u32>,
    }


    impl U32TripM  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(U32TripM {
                status: CanDataStatus::Unset,
                name:"U32TripM",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u32 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u32, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[56..88].store_le(value);

            Ok(())
        }

    } // DataTypesLe::U32TripM impl end


    impl fmt::Display for U32TripM {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("U32TripM:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for U32TripM {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("U32TripM")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DataTypesLe::U32TripM public api (CanDbcSignal trait)
    impl CanDbcSignal for U32TripM {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[56..88].load_le::<u32>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u32= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U32(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DataTypesLe::U32TripM public api

    /// DataTypesLe::I32EnergyMWh

    /// - Min: -2147483648
    /// - Max: 2147483647
    /// - Unit: "mWh"
    /// - Receivers: LOGGER
    /// - Start bit: 88
    /// - Signal size: 32 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct I32EnergyMWh {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<i32>,
    }


    impl I32EnergyMWh  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(I32EnergyMWh {
                status: CanDataStatus::Unset,
                name:"I32EnergyMWh",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> i32 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:i32, data:&mut [u8]) -> Result<(),CanError> {
            let value = u32::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[88..120].store_le(value);

            Ok(())
        }

    } // DataTypesLe::I32EnergyMWh impl end


    impl fmt::Display for I32EnergyMWh {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("I32EnergyMWh:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for I32EnergyMWh {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("I32EnergyMWh")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DataTypesLe::I32EnergyMWh public api (CanDbcSignal trait)
    impl CanDbcSignal for I32EnergyMWh {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[88..120].load_le::<u32>();

                    let value = i32::from_ne_bytes(value.to_ne_bytes());

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:i32= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::I32(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DataTypesLe::I32EnergyMWh public api

    /// DataTypesLe::U64TimestampMs

    /// - Min: 0
    /// - Max: 18446744073709552000
    /// - Unit: "ms"
    /// - Receivers: LOGGER
    /// - Start bit: 120
    /// - Signal size: 64 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct U64TimestampMs {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u64>,
    }


    impl U64TimestampMs  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(U64TimestampMs {
                status: CanDataStatus::Unset,
                name:"U64TimestampMs",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u64, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[120..184].store_le(value);

            Ok(())
        }

    } // DataTypesLe::U64TimestampMs impl end


    impl fmt::Display for U64TimestampMs {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("U64TimestampMs:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for U64TimestampMs {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("U64TimestampMs")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DataTypesLe::U64TimestampMs public api (CanDbcSignal trait)
    impl CanDbcSignal for U64TimestampMs {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[120..184].load_le::<u64>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DataTypesLe::U64TimestampMs public api

    /// DataTypesLe::I64BalanceNA

    /// - Min: -9223372036854776000
    /// - Max: 9223372036854776000
    /// - Unit: "nA"
    /// - Receivers: LOGGER
    /// - Start bit: 184
    /// - Signal size: 64 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct I64BalanceNA {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<i64>,
    }


    impl I64BalanceNA  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(I64BalanceNA {
                status: CanDataStatus::Unset,
                name:"I64BalanceNA",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> i64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:i64, data:&mut [u8]) -> Result<(),CanError> {
            let value = u64::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[184..248].store_le(value);

            Ok(())
        }

    } // DataTypesLe::I64BalanceNA impl end


    impl fmt::Display for I64BalanceNA {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("I64BalanceNA:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for I64BalanceNA {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("I64BalanceNA")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DataTypesLe::I64BalanceNA public api (CanDbcSignal trait)
    impl CanDbcSignal for I64BalanceNA {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[184..248].load_le::<u64>();

                    let value = i64::from_ne_bytes(value.to_ne_bytes());

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:i64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::I64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DataTypesLe::I64BalanceNA public api


    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;9],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 400,
                name: "DataTypesLe",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    FlagReadyBool::new(),
                    U8Counter::new(),
                    I8TempRaw::new(),
                    U16OdometerDm::new(),
                    I16TorqueRaw::new(),
                    U32TripM::new(),
                    I32EnergyMWh::new(),
                    U64TimestampMs::new(),
                    I64BalanceNA::new(),

                ],
            })))
        }


        pub fn set_values(&mut self, flag_ready_bool: bool, u8_counter: u8, i8_temp_raw: i8, u16_odometer_dm: u16, i16_torque_raw: i16, u32_trip_m: u32, i32_energy_m_wh: i32, u64_timestamp_ms: u64, i64_balance_n_a: i64, frame: &mut[u8]) -> Result<&mut Self, CanError> {


            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(flag_ready_bool), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error flag_ready_bool:Bool")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(u8_counter), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error u8_counter:U8")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::I8(i8_temp_raw), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error i8_temp_raw:I8")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(u16_odometer_dm), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error u16_odometer_dm:U16")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::I16(i16_torque_raw), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error i16_torque_raw:I16")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U32(u32_trip_m), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error u32_trip_m:U32")),
            }

            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::I32(i32_energy_m_wh), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error i32_energy_m_wh:I32")),
            }

            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U64(u64_timestamp_ms), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error u64_timestamp_ms:U64")),
            }

            match Rc::clone (&self.signals[8]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::I64(i64_balance_n_a), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error i64_balance_n_a:I64")),
            }

            Ok(self)
        }
    }


    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error flag_ready_bool:Bool")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error u8_counter:U8")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error i8_temp_raw:I8")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error u16_odometer_dm:U16")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error i16_torque_raw:I16")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error u32_trip_m:U32")),
            }

            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error i32_energy_m_wh:I32")),
            }

            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error u64_timestamp_ms:U64")),
            }

            match Rc::clone (&self.signals[8]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error i64_balance_n_a:I64")),
            }

        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error flag_ready_bool:Bool")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error u8_counter:U8")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error i8_temp_raw:I8")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error u16_odometer_dm:U16")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error i16_torque_raw:I16")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error u32_trip_m:U32")),
            }

            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error i32_energy_m_wh:I32")),
            }

            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error u64_timestamp_ms:U64")),
            }

            match Rc::clone (&self.signals[8]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error i64_balance_n_a:I64")),
            }

            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end DataTypesLe impl for CanDbcMessage

} // end DataTypesLe message


/// DataTypes_BE Message
/// - ID: 401 (0x191)
/// - Size: 64 bytes
/// - Transmitter: SENSOR_GATEWAY
///
/// Big-endian type coverage frame (includes scaling and 64-bit unsigned).

pub mod DataTypesBe { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        FlagErrorBool,
        U8ModeBe,
        I8DeltaBe,
        U16PressureKPaBe,
        I16RateDpsBe,
        U32CrcBe,
        I32PosMmBe,
        U64TripHashBe,

    }

    /// DataTypesBe::FlagErrorBool

    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct FlagErrorBool {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<bool>,
    }

    // DBC definition for MsgID:401 Signal:flag_error_bool
    #[derive(Serialize, Deserialize)]
    pub enum DbcFlagErrorBool {
        No,
        Yes,

        _Other(bool),
    }

    impl From<DbcFlagErrorBool> for bool {
        fn from (val: DbcFlagErrorBool) -> bool {
            match val {
                DbcFlagErrorBool::No => false,
                DbcFlagErrorBool::Yes => true,

                DbcFlagErrorBool::_Other(x) => x
            }
        }
    }


    impl FlagErrorBool  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(FlagErrorBool {
                status: CanDataStatus::Unset,
                name:"FlagErrorBool",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }
        pub fn get_as_def (&self) -> DbcFlagErrorBool {
            match self.get_typed_value() {
                false => DbcFlagErrorBool::No,
                true => DbcFlagErrorBool::Yes,
            }

        }
        pub fn set_raw_value(&mut self, value: u8, data: &mut[u8]) {
            data.view_bits_mut::<Msb0>()[7..8].store_be(value);

        }
        pub fn set_as_def (&mut self, signal_def: DbcFlagErrorBool, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcFlagErrorBool::No => Ok(self.set_raw_value(0, data)),
                DbcFlagErrorBool::Yes => Ok(self.set_raw_value(1, data)),
                DbcFlagErrorBool::_Other(x) => self.set_typed_value(x,data)
            }
        }

        fn get_typed_value(&self) -> bool {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[7..8].store_be(value);

            Ok(())
        }

    } // DataTypesBe::FlagErrorBool impl end


    impl fmt::Display for FlagErrorBool {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("FlagErrorBool:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for FlagErrorBool {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("FlagErrorBool")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DataTypesBe::FlagErrorBool public api (CanDbcSignal trait)
    impl CanDbcSignal for FlagErrorBool {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[7..8].load_be::<u8>();

                    let newval = value == 1;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                    };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                        self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DataTypesBe::FlagErrorBool public api

    /// DataTypesBe::U8ModeBe

    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct U8ModeBe {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }


    impl U8ModeBe  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(U8ModeBe {
                status: CanDataStatus::Unset,
                name:"U8ModeBe",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[15..23].store_be(value);

            Ok(())
        }

    } // DataTypesBe::U8ModeBe impl end


    impl fmt::Display for U8ModeBe {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("U8ModeBe:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for U8ModeBe {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("U8ModeBe")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DataTypesBe::U8ModeBe public api (CanDbcSignal trait)
    impl CanDbcSignal for U8ModeBe {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[15..23].load_be::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DataTypesBe::U8ModeBe public api

    /// DataTypesBe::I8DeltaBe

    /// - Min: -128
    /// - Max: 127
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct I8DeltaBe {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<i8>,
    }


    impl I8DeltaBe  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(I8DeltaBe {
                status: CanDataStatus::Unset,
                name:"I8DeltaBe",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> i8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:i8, data:&mut [u8]) -> Result<(),CanError> {
            let value = u8::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Msb0>()[23..31].store_be(value);

            Ok(())
        }

    } // DataTypesBe::I8DeltaBe impl end


    impl fmt::Display for I8DeltaBe {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("I8DeltaBe:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for I8DeltaBe {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("I8DeltaBe")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DataTypesBe::I8DeltaBe public api (CanDbcSignal trait)
    impl CanDbcSignal for I8DeltaBe {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[23..31].load_be::<u8>();

                    let value = i8::from_ne_bytes(value.to_ne_bytes());

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:i8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::I8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DataTypesBe::I8DeltaBe public api

    /// DataTypesBe::U16PressureKPaBe

    /// - Min: 0
    /// - Max: 32767.5
    /// - Unit: "kPa"
    /// - Receivers: LOGGER
    /// - Start bit: 24
    /// - Signal size: 16 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct U16PressureKPaBe {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl U16PressureKPaBe  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(U16PressureKPaBe {
                status: CanDataStatus::Unset,
                name:"U16PressureKPaBe",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < 0_f64 || 32767.5_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [0..32767.5]",value)));
            }
            let factor = 0.5_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            data.view_bits_mut::<Msb0>()[31..47].store_be(value);

            Ok(())
        }

    } // DataTypesBe::U16PressureKPaBe impl end


    impl fmt::Display for U16PressureKPaBe {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("U16PressureKPaBe:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for U16PressureKPaBe {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("U16PressureKPaBe")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DataTypesBe::U16PressureKPaBe public api (CanDbcSignal trait)
    impl CanDbcSignal for U16PressureKPaBe {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[31..47].load_be::<u16>();

                    let factor = 0.5_f64;
                    let offset = 0_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DataTypesBe::U16PressureKPaBe public api

    /// DataTypesBe::I16RateDpsBe

    /// - Min: -327.68
    /// - Max: 327.67
    /// - Unit: "deg/s"
    /// - Receivers: LOGGER
    /// - Start bit: 40
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct I16RateDpsBe {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl I16RateDpsBe  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(I16RateDpsBe {
                status: CanDataStatus::Unset,
                name:"I16RateDpsBe",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < -327.68_f64 || 327.67_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-327.68..327.67]",value)));
            }
            let factor = 0.01_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            let value = u16::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Msb0>()[47..63].store_be(value);

            Ok(())
        }

    } // DataTypesBe::I16RateDpsBe impl end


    impl fmt::Display for I16RateDpsBe {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("I16RateDpsBe:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for I16RateDpsBe {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("I16RateDpsBe")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DataTypesBe::I16RateDpsBe public api (CanDbcSignal trait)
    impl CanDbcSignal for I16RateDpsBe {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[47..63].load_be::<u16>();

                    let value = i16::from_ne_bytes(value.to_ne_bytes());

                    let factor = 0.01_f64;
                    let offset = 0_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DataTypesBe::I16RateDpsBe public api

    /// DataTypesBe::U32CrcBe

    /// - Min: 0
    /// - Max: 4294967295
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 56
    /// - Signal size: 32 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct U32CrcBe {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u32>,
    }


    impl U32CrcBe  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(U32CrcBe {
                status: CanDataStatus::Unset,
                name:"U32CrcBe",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u32 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u32, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[63..95].store_be(value);

            Ok(())
        }

    } // DataTypesBe::U32CrcBe impl end


    impl fmt::Display for U32CrcBe {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("U32CrcBe:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for U32CrcBe {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("U32CrcBe")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DataTypesBe::U32CrcBe public api (CanDbcSignal trait)
    impl CanDbcSignal for U32CrcBe {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[63..95].load_be::<u32>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u32= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U32(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DataTypesBe::U32CrcBe public api

    /// DataTypesBe::I32PosMmBe

    /// - Min: -2147483648
    /// - Max: 2147483647
    /// - Unit: "mm"
    /// - Receivers: LOGGER
    /// - Start bit: 88
    /// - Signal size: 32 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct I32PosMmBe {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<i32>,
    }


    impl I32PosMmBe  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(I32PosMmBe {
                status: CanDataStatus::Unset,
                name:"I32PosMmBe",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> i32 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:i32, data:&mut [u8]) -> Result<(),CanError> {
            let value = u32::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Msb0>()[95..127].store_be(value);

            Ok(())
        }

    } // DataTypesBe::I32PosMmBe impl end


    impl fmt::Display for I32PosMmBe {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("I32PosMmBe:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for I32PosMmBe {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("I32PosMmBe")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DataTypesBe::I32PosMmBe public api (CanDbcSignal trait)
    impl CanDbcSignal for I32PosMmBe {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[95..127].load_be::<u32>();

                    let value = i32::from_ne_bytes(value.to_ne_bytes());

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:i32= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::I32(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DataTypesBe::I32PosMmBe public api

    /// DataTypesBe::U64TripHashBe

    /// - Min: 0
    /// - Max: 18446744073709552000
    /// - Unit: ""
    /// - Receivers: LOGGER
    /// - Start bit: 120
    /// - Signal size: 64 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct U64TripHashBe {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u64>,
    }


    impl U64TripHashBe  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(U64TripHashBe {
                status: CanDataStatus::Unset,
                name:"U64TripHashBe",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> u64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u64, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[127..191].store_be(value);

            Ok(())
        }

    } // DataTypesBe::U64TripHashBe impl end


    impl fmt::Display for U64TripHashBe {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("U64TripHashBe:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for U64TripHashBe {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("U64TripHashBe")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// DataTypesBe::U64TripHashBe public api (CanDbcSignal trait)
    impl CanDbcSignal for U64TripHashBe {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[127..191].load_be::<u64>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end DataTypesBe::U64TripHashBe public api


    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;8],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 401,
                name: "DataTypesBe",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    FlagErrorBool::new(),
                    U8ModeBe::new(),
                    I8DeltaBe::new(),
                    U16PressureKPaBe::new(),
                    I16RateDpsBe::new(),
                    U32CrcBe::new(),
                    I32PosMmBe::new(),
                    U64TripHashBe::new(),

                ],
            })))
        }


        pub fn set_values(&mut self, flag_error_bool: bool, u8_mode_be: u8, i8_delta_be: i8, u16_pressure_k_pa_be: f64, i16_rate_dps_be: f64, u32_crc_be: u32, i32_pos_mm_be: i32, u64_trip_hash_be: u64, frame: &mut[u8]) -> Result<&mut Self, CanError> {


            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(flag_error_bool), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error flag_error_bool:Bool")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(u8_mode_be), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error u8_mode_be:U8")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::I8(i8_delta_be), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error i8_delta_be:I8")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(u16_pressure_k_pa_be), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error u16_pressure_k_pa_be:F64")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(i16_rate_dps_be), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error i16_rate_dps_be:F64")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U32(u32_crc_be), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error u32_crc_be:U32")),
            }

            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::I32(i32_pos_mm_be), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error i32_pos_mm_be:I32")),
            }

            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U64(u64_trip_hash_be), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error u64_trip_hash_be:U64")),
            }

            Ok(self)
        }
    }


    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error flag_error_bool:Bool")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error u8_mode_be:U8")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error i8_delta_be:I8")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error u16_pressure_k_pa_be:F64")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error i16_rate_dps_be:F64")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error u32_crc_be:U32")),
            }

            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error i32_pos_mm_be:I32")),
            }

            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error u64_trip_hash_be:U64")),
            }

        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error flag_error_bool:Bool")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error u8_mode_be:U8")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error i8_delta_be:I8")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error u16_pressure_k_pa_be:F64")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error i16_rate_dps_be:F64")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error u32_crc_be:U32")),
            }

            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error i32_pos_mm_be:I32")),
            }

            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error u64_trip_hash_be:U64")),
            }

            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end DataTypesBe impl for CanDbcMessage

} // end DataTypesBe message

enum DbcMessages {
    VehicleStatus,
    EnergyPackStatus,
    PowertrainMux,
    ChassisControl,
    DiagFdFrame,
    MuxTest,
    DataTypesLe,
    DataTypesBe,

}

pub struct CanMsgPool {
    uid: &'static str,
    pool: [Rc<RefCell<Box<dyn CanDbcMessage>>>;8],
}

impl CanMsgPool {
    pub fn new(uid: &'static str) -> Self {
        CanMsgPool {
            uid: uid,
            pool: [
                VehicleStatus::DbcMessage::new(),
                EnergyPackStatus::DbcMessage::new(),
                PowertrainMux::DbcMessage::new(),
                ChassisControl::DbcMessage::new(),
                DiagFdFrame::DbcMessage::new(),
                MuxTest::DbcMessage::new(),
                DataTypesLe::DbcMessage::new(),
                DataTypesBe::DbcMessage::new(),

            ]
        }
    }
}

impl CanDbcPool for CanMsgPool {
    fn get_messages(&self) -> &[Rc<RefCell<Box<dyn CanDbcMessage>>>] {
        &self.pool
    }

    fn get_ids(&self) -> &[u32] {
        &[100, 101, 200, 210, 300, 322, 400, 401]
    }

    fn get_mut(&self, canid: u32) -> Result<RefMut<'_, Box<dyn CanDbcMessage>>, CanError> {
        let search= self.pool.binary_search_by(|msg| msg.borrow().get_id().cmp(&canid));
        match search {
            Ok(idx) => {
                match self.pool[idx].try_borrow_mut() {
                    Err(_code) => Err(CanError::new("message-get_mut", "internal msg pool error")),
                    Ok(mut_ref) => Ok(mut_ref),
                }
            },
            Err(_) => Err(CanError::new("fail-canid-search", format!("canid:{} not found",canid))),
        }
    }

    fn update(&self, data: &CanMsgData) -> Result<RefMut<'_, Box<dyn CanDbcMessage>>, CanError> {
        let mut msg= match self.get_mut(data.canid) {
            Err(error) => return Err(error),
            Ok(msg_ref) => msg_ref,
        };
        msg.update(data)?;
        Ok(msg)
    }
 }
} // end dbc generated parser
