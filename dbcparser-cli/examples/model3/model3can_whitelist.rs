
// -----------------------------------------------------------------------
//              <- DBC file Rust mapping ->
// -----------------------------------------------------------------------
//  Do not edit this file it will be regenerated automatically by cargo.
//  Check:
//   - build.rs at project root for dynamically mapping
//   - example/demo/dbc-log/??? for static values
//  Reference: iot.bzh/Redpesk canbus-rs code generator
// -----------------------------------------------------------------------

// Tell rustfmt (stable) to skip formatting this whole file
#[rustfmt::skip]

#[allow(
    warnings,
    clippy::all,
    clippy::pedantic,
    clippy::nursery,
    clippy::redundant_field_names,
    clippy::similar_names
)]

// --------------------------------------------------------------
//       WARNING: Manual modification will be destroyed
// --------------------------------------------------------------
// - code generated from /home/ronan/Iot/rust/canforge-rs/dbcparser-cli/.tmpg68Tql/../examples/model3/dbc/model3can.dbc (Tue Nov 18 12:25:54 2025)
// - update only with [dbc-parser|build.rs::DbcParser]
// - source code: https://github.com/redpesk-labs/canbus-rs
// - (C)IoT.bzh(2023), Author: Fulup Ar Foll, http://redpesk.bzh
// - License: $RP_BEGIN_LICENSE$ SPDX:MIT https://opensource.org/licenses/MIT $RP_END_LICENSE$
// -------------------------------------------------------------
mod DbcSimple {
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
extern crate serde;
extern crate bitvec;
use sockcan::prelude::*;
use std::cell::{RefCell,RefMut};
use std::rc::{Rc};

/// ID101RCM_inertial1 Message
/// - ID: 257 (0x101)
/// - Size: 8 bytes
/// - Transmitter: ChassisBus
pub mod Id101rcmInertial1 { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        RcmInertial1Checksum,
        RcmInertial1Counter,
        RcmPitchRate,
        RcmPitchRateQf,
        RcmRollRate,
        RcmRollRateQf,
        RcmYawRate,
        RcmYawRateQf,
    }

    /// Id101rcmInertial1::RcmInertial1Checksum
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct RcmInertial1Checksum {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u8,
    }

    impl RcmInertial1Checksum  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(RcmInertial1Checksum {
                status: CanDataStatus::Unset,
                name:"RcmInertial1Checksum",
                value: 0_u8,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u8;
        }

        fn get_typed_value(&self) -> u8 {
            self.value
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[56..64].store_le(value);
            Ok(())
        }

    } // Id101rcmInertial1::RcmInertial1Checksum impl end

    impl fmt::Display for RcmInertial1Checksum {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("RcmInertial1Checksum:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for RcmInertial1Checksum {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("RcmInertial1Checksum")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// Id101rcmInertial1::RcmInertial1Checksum public api (CanDbcSignal trait)
    impl CanDbcSignal for RcmInertial1Checksum {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[56..64].load_le::<u8>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end Id101rcmInertial1::RcmInertial1Checksum public api

    /// Id101rcmInertial1::RcmInertial1Counter
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    /// - Start bit: 52
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct RcmInertial1Counter {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u8,
    }

    impl RcmInertial1Counter  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(RcmInertial1Counter {
                status: CanDataStatus::Unset,
                name:"RcmInertial1Counter",
                value: 0_u8,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u8;
        }

        fn get_typed_value(&self) -> u8 {
            self.value
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[52..56].store_le(value);
            Ok(())
        }

    } // Id101rcmInertial1::RcmInertial1Counter impl end

    impl fmt::Display for RcmInertial1Counter {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("RcmInertial1Counter:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for RcmInertial1Counter {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("RcmInertial1Counter")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// Id101rcmInertial1::RcmInertial1Counter public api (CanDbcSignal trait)
    impl CanDbcSignal for RcmInertial1Counter {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[52..56].load_le::<u8>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end Id101rcmInertial1::RcmInertial1Counter public api

    /// Id101rcmInertial1::RcmPitchRate
    ///
    /// Pitch
    /// - Min: -4.096
    /// - Max: 4.09575
    /// - Unit: "rad/s"
    /// - Receivers: Receiver
    /// - Start bit: 16
    /// - Signal size: 15 bits
    /// - Factor: 0.00025
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct RcmPitchRate {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: f64,
    }

    // DBC definition for MsgID:257 Signal:RCM_pitchRate
    #[derive(Serialize, Deserialize)]
    pub enum DbcRcmPitchRate {
        Sna,
        _Other(f64),
    }

    impl From<DbcRcmPitchRate> for f64 {
        fn from (val: DbcRcmPitchRate) -> f64 {
            match val {
                DbcRcmPitchRate::Sna => panic! ("(Hoops) impossible conversion 16384_f64 -> f64"),
                DbcRcmPitchRate::_Other(x) => x
            }
        }
    }

    impl RcmPitchRate  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(RcmPitchRate {
                status: CanDataStatus::Unset,
                name:"RcmPitchRate",
                value: 0_f64,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_f64;
        }

        pub fn get_as_def (&self) -> DbcRcmPitchRate {
                DbcRcmPitchRate::_Other(self.get_typed_value())
        }

        pub fn set_as_def (&mut self, signal_def: DbcRcmPitchRate, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcRcmPitchRate::Sna => Err(CanError::new("not-in-range","(Sna) !!! 16384(f64) not in [-4.096..4.09575] range")),
                DbcRcmPitchRate::_Other(x) => self.set_typed_value(x,data)
            }
        }
        fn get_typed_value(&self) -> f64 {
            self.value
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {
            if value < -4.096_f64 || 4.09575_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-4.096..4.09575]",value)));
            }
            let factor = 0.00025_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            let value = u16::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[16..31].store_le(value);
            Ok(())
        }

    } // Id101rcmInertial1::RcmPitchRate impl end

    impl fmt::Display for RcmPitchRate {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("RcmPitchRate:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for RcmPitchRate {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("RcmPitchRate")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// Id101rcmInertial1::RcmPitchRate public api (CanDbcSignal trait)
    impl CanDbcSignal for RcmPitchRate {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[16..31].load_le::<u16>();
                    let value = i16::from_ne_bytes(value.to_ne_bytes());
                    let factor = 0.00025_f64;
                    let offset = 0_f64;
                    let newval= (value as f64) * factor + offset;
                    if newval != self.value {
                        self.value= newval;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end Id101rcmInertial1::RcmPitchRate public api

    /// Id101rcmInertial1::RcmPitchRateQf
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    /// - Start bit: 50
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct RcmPitchRateQf {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u8,
    }

    // DBC definition for MsgID:257 Signal:RCM_pitchRateQF
    #[derive(Serialize, Deserialize)]
    pub enum DbcRcmPitchRateQf {
        Faulted,
        Init,
        TempInvalid,
        Valid,
        _Other(u8),
    }

    impl From<DbcRcmPitchRateQf> for u8 {
        fn from (val: DbcRcmPitchRateQf) -> u8 {
            match val {
                DbcRcmPitchRateQf::Faulted => 3_u8,
                DbcRcmPitchRateQf::Init => 0_u8,
                DbcRcmPitchRateQf::TempInvalid => 2_u8,
                DbcRcmPitchRateQf::Valid => 1_u8,
                DbcRcmPitchRateQf::_Other(x) => x
            }
        }
    }

    impl RcmPitchRateQf  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(RcmPitchRateQf {
                status: CanDataStatus::Unset,
                name:"RcmPitchRateQf",
                value: 0_u8,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u8;
        }

        pub fn get_as_def (&self) -> DbcRcmPitchRateQf {
            match self.get_typed_value() {
                3_u8 => DbcRcmPitchRateQf::Faulted,
                0_u8 => DbcRcmPitchRateQf::Init,
                2_u8 => DbcRcmPitchRateQf::TempInvalid,
                1_u8 => DbcRcmPitchRateQf::Valid,
                _ => DbcRcmPitchRateQf::_Other(self.get_typed_value()),
            }
        }

        pub fn set_as_def (&mut self, signal_def: DbcRcmPitchRateQf, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcRcmPitchRateQf::Faulted => self.set_typed_value(3_u8, data),
                DbcRcmPitchRateQf::Init => self.set_typed_value(0_u8, data),
                DbcRcmPitchRateQf::TempInvalid => self.set_typed_value(2_u8, data),
                DbcRcmPitchRateQf::Valid => self.set_typed_value(1_u8, data),
                DbcRcmPitchRateQf::_Other(x) => self.set_typed_value(x,data)
            }
        }
        fn get_typed_value(&self) -> u8 {
            self.value
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[50..52].store_le(value);
            Ok(())
        }

    } // Id101rcmInertial1::RcmPitchRateQf impl end

    impl fmt::Display for RcmPitchRateQf {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("RcmPitchRateQf:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for RcmPitchRateQf {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("RcmPitchRateQf")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// Id101rcmInertial1::RcmPitchRateQf public api (CanDbcSignal trait)
    impl CanDbcSignal for RcmPitchRateQf {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[50..52].load_le::<u8>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end Id101rcmInertial1::RcmPitchRateQf public api

    /// Id101rcmInertial1::RcmRollRate
    ///
    /// Roll
    /// - Min: -4.096
    /// - Max: 4.09575
    /// - Unit: "rad/s"
    /// - Receivers: Receiver
    /// - Start bit: 31
    /// - Signal size: 15 bits
    /// - Factor: 0.00025
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct RcmRollRate {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: f64,
    }

    // DBC definition for MsgID:257 Signal:RCM_rollRate
    #[derive(Serialize, Deserialize)]
    pub enum DbcRcmRollRate {
        Sna,
        _Other(f64),
    }

    impl From<DbcRcmRollRate> for f64 {
        fn from (val: DbcRcmRollRate) -> f64 {
            match val {
                DbcRcmRollRate::Sna => panic! ("(Hoops) impossible conversion 16384_f64 -> f64"),
                DbcRcmRollRate::_Other(x) => x
            }
        }
    }

    impl RcmRollRate  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(RcmRollRate {
                status: CanDataStatus::Unset,
                name:"RcmRollRate",
                value: 0_f64,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_f64;
        }

        pub fn get_as_def (&self) -> DbcRcmRollRate {
                DbcRcmRollRate::_Other(self.get_typed_value())
        }

        pub fn set_as_def (&mut self, signal_def: DbcRcmRollRate, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcRcmRollRate::Sna => Err(CanError::new("not-in-range","(Sna) !!! 16384(f64) not in [-4.096..4.09575] range")),
                DbcRcmRollRate::_Other(x) => self.set_typed_value(x,data)
            }
        }
        fn get_typed_value(&self) -> f64 {
            self.value
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {
            if value < -4.096_f64 || 4.09575_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-4.096..4.09575]",value)));
            }
            let factor = 0.00025_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            let value = u16::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[31..46].store_le(value);
            Ok(())
        }

    } // Id101rcmInertial1::RcmRollRate impl end

    impl fmt::Display for RcmRollRate {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("RcmRollRate:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for RcmRollRate {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("RcmRollRate")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// Id101rcmInertial1::RcmRollRate public api (CanDbcSignal trait)
    impl CanDbcSignal for RcmRollRate {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[31..46].load_le::<u16>();
                    let value = i16::from_ne_bytes(value.to_ne_bytes());
                    let factor = 0.00025_f64;
                    let offset = 0_f64;
                    let newval= (value as f64) * factor + offset;
                    if newval != self.value {
                        self.value= newval;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end Id101rcmInertial1::RcmRollRate public api

    /// Id101rcmInertial1::RcmRollRateQf
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    /// - Start bit: 46
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct RcmRollRateQf {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u8,
    }

    // DBC definition for MsgID:257 Signal:RCM_rollRateQF
    #[derive(Serialize, Deserialize)]
    pub enum DbcRcmRollRateQf {
        Faulted,
        Init,
        TempInvalid,
        Valid,
        _Other(u8),
    }

    impl From<DbcRcmRollRateQf> for u8 {
        fn from (val: DbcRcmRollRateQf) -> u8 {
            match val {
                DbcRcmRollRateQf::Faulted => 3_u8,
                DbcRcmRollRateQf::Init => 0_u8,
                DbcRcmRollRateQf::TempInvalid => 2_u8,
                DbcRcmRollRateQf::Valid => 1_u8,
                DbcRcmRollRateQf::_Other(x) => x
            }
        }
    }

    impl RcmRollRateQf  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(RcmRollRateQf {
                status: CanDataStatus::Unset,
                name:"RcmRollRateQf",
                value: 0_u8,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u8;
        }

        pub fn get_as_def (&self) -> DbcRcmRollRateQf {
            match self.get_typed_value() {
                3_u8 => DbcRcmRollRateQf::Faulted,
                0_u8 => DbcRcmRollRateQf::Init,
                2_u8 => DbcRcmRollRateQf::TempInvalid,
                1_u8 => DbcRcmRollRateQf::Valid,
                _ => DbcRcmRollRateQf::_Other(self.get_typed_value()),
            }
        }

        pub fn set_as_def (&mut self, signal_def: DbcRcmRollRateQf, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcRcmRollRateQf::Faulted => self.set_typed_value(3_u8, data),
                DbcRcmRollRateQf::Init => self.set_typed_value(0_u8, data),
                DbcRcmRollRateQf::TempInvalid => self.set_typed_value(2_u8, data),
                DbcRcmRollRateQf::Valid => self.set_typed_value(1_u8, data),
                DbcRcmRollRateQf::_Other(x) => self.set_typed_value(x,data)
            }
        }
        fn get_typed_value(&self) -> u8 {
            self.value
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[46..48].store_le(value);
            Ok(())
        }

    } // Id101rcmInertial1::RcmRollRateQf impl end

    impl fmt::Display for RcmRollRateQf {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("RcmRollRateQf:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for RcmRollRateQf {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("RcmRollRateQf")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// Id101rcmInertial1::RcmRollRateQf public api (CanDbcSignal trait)
    impl CanDbcSignal for RcmRollRateQf {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[46..48].load_le::<u8>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end Id101rcmInertial1::RcmRollRateQf public api

    /// Id101rcmInertial1::RcmYawRate
    ///
    /// Yaw
    /// - Min: -3.2766
    /// - Max: 3.2766
    /// - Unit: "rad/s"
    /// - Receivers: Receiver
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct RcmYawRate {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: f64,
    }

    // DBC definition for MsgID:257 Signal:RCM_yawRate
    #[derive(Serialize, Deserialize)]
    pub enum DbcRcmYawRate {
        Sna,
        _Other(f64),
    }

    impl From<DbcRcmYawRate> for f64 {
        fn from (val: DbcRcmYawRate) -> f64 {
            match val {
                DbcRcmYawRate::Sna => panic! ("(Hoops) impossible conversion 32768_f64 -> f64"),
                DbcRcmYawRate::_Other(x) => x
            }
        }
    }

    impl RcmYawRate  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(RcmYawRate {
                status: CanDataStatus::Unset,
                name:"RcmYawRate",
                value: 0_f64,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_f64;
        }

        pub fn get_as_def (&self) -> DbcRcmYawRate {
                DbcRcmYawRate::_Other(self.get_typed_value())
        }

        pub fn set_as_def (&mut self, signal_def: DbcRcmYawRate, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcRcmYawRate::Sna => Err(CanError::new("not-in-range","(Sna) !!! 32768(f64) not in [-3.2766..3.2766] range")),
                DbcRcmYawRate::_Other(x) => self.set_typed_value(x,data)
            }
        }
        fn get_typed_value(&self) -> f64 {
            self.value
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {
            if value < -3.2766_f64 || 3.2766_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-3.2766..3.2766]",value)));
            }
            let factor = 0.0001_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            let value = u16::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[0..16].store_le(value);
            Ok(())
        }

    } // Id101rcmInertial1::RcmYawRate impl end

    impl fmt::Display for RcmYawRate {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("RcmYawRate:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for RcmYawRate {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("RcmYawRate")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// Id101rcmInertial1::RcmYawRate public api (CanDbcSignal trait)
    impl CanDbcSignal for RcmYawRate {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[0..16].load_le::<u16>();
                    let value = i16::from_ne_bytes(value.to_ne_bytes());
                    let factor = 0.0001_f64;
                    let offset = 0_f64;
                    let newval= (value as f64) * factor + offset;
                    if newval != self.value {
                        self.value= newval;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end Id101rcmInertial1::RcmYawRate public api

    /// Id101rcmInertial1::RcmYawRateQf
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    /// - Start bit: 48
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct RcmYawRateQf {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    // DBC definition for MsgID:257 Signal:RCM_yawRateQF
    #[derive(Serialize, Deserialize)]
    pub enum DbcRcmYawRateQf {
        Faulted,
        NotFaulted,
        _Other(bool),
    }

    impl From<DbcRcmYawRateQf> for bool {
        fn from (val: DbcRcmYawRateQf) -> bool {
            match val {
                DbcRcmYawRateQf::Faulted => false,
                DbcRcmYawRateQf::NotFaulted => true,
                DbcRcmYawRateQf::_Other(x) => x
            }
        }
    }

    impl RcmYawRateQf  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(RcmYawRateQf {
                status: CanDataStatus::Unset,
                name:"RcmYawRateQf",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        pub fn get_as_def (&self) -> DbcRcmYawRateQf {
            match self.get_typed_value() {
                false => DbcRcmYawRateQf::Faulted,
                true => DbcRcmYawRateQf::NotFaulted,
            }
        }

        pub fn set_as_def (&mut self, signal_def: DbcRcmYawRateQf, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcRcmYawRateQf::Faulted => self.set_typed_value(false, data),
                DbcRcmYawRateQf::NotFaulted => self.set_typed_value(true, data),
                DbcRcmYawRateQf::_Other(x) => self.set_typed_value(x,data)
            }
        }
        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Lsb0>()[48..49].store_le(value);
            Ok(())
        }

    } // Id101rcmInertial1::RcmYawRateQf impl end

    impl fmt::Display for RcmYawRateQf {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("RcmYawRateQf:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for RcmYawRateQf {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("RcmYawRateQf")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// Id101rcmInertial1::RcmYawRateQf public api (CanDbcSignal trait)
    impl CanDbcSignal for RcmYawRateQf {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[48..49].load_le::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end Id101rcmInertial1::RcmYawRateQf public api

    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;8],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 257,
                name: "Id101rcmInertial1",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    RcmInertial1Checksum::new(),
                    RcmInertial1Counter::new(),
                    RcmPitchRate::new(),
                    RcmPitchRateQf::new(),
                    RcmRollRate::new(),
                    RcmRollRateQf::new(),
                    RcmYawRate::new(),
                    RcmYawRateQf::new(),
                ],
            })))
        }

        pub fn set_values(&mut self, rcm_inertial1_checksum: u8, rcm_inertial1_counter: u8, rcm_pitch_rate: f64, rcm_pitch_rate_qf: u8, rcm_roll_rate: f64, rcm_roll_rate_qf: u8, rcm_yaw_rate: f64, rcm_yaw_rate_qf: bool, frame: &mut[u8]) -> Result<&mut Self, CanError> {

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(rcm_inertial1_checksum), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error rcm_inertial1_checksum:U8")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(rcm_inertial1_counter), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error rcm_inertial1_counter:U8")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(rcm_pitch_rate), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error rcm_pitch_rate:F64")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(rcm_pitch_rate_qf), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error rcm_pitch_rate_qf:U8")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(rcm_roll_rate), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error rcm_roll_rate:F64")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(rcm_roll_rate_qf), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error rcm_roll_rate_qf:U8")),
            }
            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(rcm_yaw_rate), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error rcm_yaw_rate:F64")),
            }
            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(rcm_yaw_rate_qf), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error rcm_yaw_rate_qf:Bool")),
            }
            Ok(self)
        }
    }

    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error rcm_inertial1_checksum:U8")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error rcm_inertial1_counter:U8")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error rcm_pitch_rate:F64")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error rcm_pitch_rate_qf:U8")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error rcm_roll_rate:F64")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error rcm_roll_rate_qf:U8")),
            }
            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error rcm_yaw_rate:F64")),
            }
            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error rcm_yaw_rate_qf:Bool")),
            }
        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error rcm_inertial1_checksum:U8")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error rcm_inertial1_counter:U8")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error rcm_pitch_rate:F64")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error rcm_pitch_rate_qf:U8")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error rcm_roll_rate:F64")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error rcm_roll_rate_qf:U8")),
            }
            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error rcm_yaw_rate:F64")),
            }
            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error rcm_yaw_rate_qf:Bool")),
            }
            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end Id101rcmInertial1 impl for CanDbcMessage
} // end Id101rcmInertial1 message

enum DbcMessages {
    Id101rcmInertial1,
}

pub struct CanMsgPool {
    uid: &'static str,
    pool: [Rc<RefCell<Box<dyn CanDbcMessage>>>;1],
}

impl CanMsgPool {
    pub fn new(uid: &'static str) -> Self {
        CanMsgPool {
            uid: uid,
            pool: [
                Id101rcmInertial1::DbcMessage::new(),
            ]
        }
    }
}

impl CanDbcPool for CanMsgPool {
    fn get_messages(&self) -> &[Rc<RefCell<Box<dyn CanDbcMessage>>>] {
        &self.pool
    }

    fn get_ids(&self) -> &[u32] {
        &[257]
    }

    fn get_mut(&self, canid: u32) -> Result<RefMut<'_, Box<dyn CanDbcMessage>>, CanError> {
        let search= self.pool.binary_search_by(|msg| msg.borrow().get_id().cmp(&canid));
        match search {
            Ok(idx) => {
                match self.pool[idx].try_borrow_mut() {
                    Err(_code) => Err(CanError::new("message-get_mut", "internal msg pool error")),
                    Ok(mut_ref) => Ok(mut_ref),
                }
            },
            Err(_) => Err(CanError::new("fail-canid-search", format!("canid:{} not found",canid))),
        }
    }

    fn update(&self, data: &CanMsgData) -> Result<RefMut<'_, Box<dyn CanDbcMessage>>, CanError> {
        let mut msg= match self.get_mut(data.canid) {
            Err(error) => return Err(error),
            Ok(msg_ref) => msg_ref,
        };
        msg.update(data)?;
        Ok(msg)
    }
 }
} // end dbc generated parser
