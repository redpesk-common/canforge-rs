
// -----------------------------------------------------------------------
//              <- DBC file Rust mapping ->
// -----------------------------------------------------------------------
//  Do not edit this file it will be regenerated automatically by cargo.
//  Check:
//   - build.rs at project root for dynamically mapping
//   - example/demo/dbc-log/??? for static values
//  Reference: iot.bzh/Redpesk canbus-rs code generator
// -----------------------------------------------------------------------

// Tell rustfmt (stable) to skip formatting this whole file
#[rustfmt::skip]

#[allow(
    warnings,
    clippy::all,
    clippy::pedantic,
    clippy::nursery,
    clippy::redundant_field_names,
    clippy::similar_names
)]


// --------------------------------------------------------------
//       WARNING: Manual modification will be destroyed
// --------------------------------------------------------------
// - code generated from ./dbcparser-cli/examples/canforge_dbc_complete_norm/dbc/canforge_dbc_complete_norm.dbc (Wed Jan 28 10:51:38 2026)
// - update only with [dbc-parser|build.rs::DbcParser]
// - source code: https://github.com/redpesk-common/canforge-rs
// Generated file â€” DO NOT EDIT.
// Update only with [dbc-parser|build.rs::DbcParser]
// Source: https://github.com/redpesk-common/canforge-rs
//
// Copyright (C) 2023 IoT.bzh Company
// Author: Fulup Ar Foll <fulup@iot.bzh>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// -------------------------------------------------------------
mod DbcSimple {
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
extern crate serde;

extern crate bitvec;
use sockcan::prelude::*;
use std::cell::{RefCell,RefMut};
use std::rc::{Rc};


/// MUX_TEST Message
/// - ID: 322 (0x142)
/// - Size: 8 bytes
/// - Transmitter: POWERTRAIN_CTRL
///
/// Minimal multiplexing test message. MUX_signal selects pages. Page 0: open/closed/direction/mode. Page 1: speed/temperature. Collisions between pages are intentional, but signals inside the same page do not overlap (cantools requirement).

pub mod MuxTest { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        MuxSignal,
        Open,
        Closed,
        Direction,
        Mode,
        Speed,
        Temperature,

    }

    /// MuxTest::MuxSignal
    ///
    /// Multiplexer: 0=STATE, 1=MEASURE, 2=INVALID.

    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct MuxSignal {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }

    // DBC definition for MsgID:322 Signal:MUX_signal
    #[derive(Serialize, Deserialize)]
    pub enum DbcMuxSignal {
        State,
        Measure,
        Invalid,

        _Other(u8),
    }

    impl From<DbcMuxSignal> for u8 {
        fn from (val: DbcMuxSignal) -> u8 {
            match val {
                DbcMuxSignal::State => 0_u8,
                DbcMuxSignal::Measure => 1_u8,
                DbcMuxSignal::Invalid => 2_u8,

                DbcMuxSignal::_Other(x) => x
            }
        }
    }


    impl MuxSignal  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(MuxSignal {
                status: CanDataStatus::Unset,
                name:"MuxSignal",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }
        pub fn get_as_def (&self) -> DbcMuxSignal {
            match self.get_typed_value() {
                0_u8 => DbcMuxSignal::State,
                1_u8 => DbcMuxSignal::Measure,
                2_u8 => DbcMuxSignal::Invalid,
                _ => DbcMuxSignal::_Other(self.get_typed_value()),
            }

        }
        pub fn set_raw_value(&mut self, value: u8, data: &mut[u8]) {
            data.view_bits_mut::<Lsb0>()[0..2].store_le(value);

        }
        pub fn set_as_def (&mut self, signal_def: DbcMuxSignal, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcMuxSignal::State => Ok(self.set_raw_value(0, data)),
                DbcMuxSignal::Measure => Ok(self.set_raw_value(1, data)),
                DbcMuxSignal::Invalid => Ok(self.set_raw_value(2, data)),
                DbcMuxSignal::_Other(x) => self.set_typed_value(x,data)
            }
        }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[0..2].store_le(value);

            Ok(())
        }

    } // MuxTest::MuxSignal impl end


    impl fmt::Display for MuxSignal {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("MuxSignal:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for MuxSignal {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("MuxSignal")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// MuxTest::MuxSignal public api (CanDbcSignal trait)
    impl CanDbcSignal for MuxSignal {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[0..2].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MuxTest::MuxSignal public api

    /// MuxTest::Open
    ///
    /// STATE page (MUX_signal=0). Collides with MEASURE speed bits.

    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct Open {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<bool>,
    }

    // DBC definition for MsgID:322 Signal:open
    #[derive(Serialize, Deserialize)]
    pub enum DbcOpen {
        No,
        Yes,

        _Other(bool),
    }

    impl From<DbcOpen> for bool {
        fn from (val: DbcOpen) -> bool {
            match val {
                DbcOpen::No => false,
                DbcOpen::Yes => true,

                DbcOpen::_Other(x) => x
            }
        }
    }


    impl Open  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Open {
                status: CanDataStatus::Unset,
                name:"Open",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }
        pub fn get_as_def (&self) -> DbcOpen {
            match self.get_typed_value() {
                false => DbcOpen::No,
                true => DbcOpen::Yes,
            }

        }
        pub fn set_raw_value(&mut self, value: u8, data: &mut[u8]) {
            data.view_bits_mut::<Lsb0>()[3..4].store_le(value);

        }
        pub fn set_as_def (&mut self, signal_def: DbcOpen, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcOpen::No => Ok(self.set_raw_value(0, data)),
                DbcOpen::Yes => Ok(self.set_raw_value(1, data)),
                DbcOpen::_Other(x) => self.set_typed_value(x,data)
            }
        }

        fn get_typed_value(&self) -> bool {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Lsb0>()[3..4].store_le(value);

            Ok(())
        }

    } // MuxTest::Open impl end


    impl fmt::Display for Open {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Open:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Open {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Open")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// MuxTest::Open public api (CanDbcSignal trait)
    impl CanDbcSignal for Open {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[3..4].load_le::<u8>();

                    let newval = value == 1;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                    };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                        self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MuxTest::Open public api

    /// MuxTest::Closed
    ///
    /// STATE page (MUX_signal=0). Collides with MEASURE speed bits.

    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct Closed {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<bool>,
    }

    // DBC definition for MsgID:322 Signal:closed
    #[derive(Serialize, Deserialize)]
    pub enum DbcClosed {
        No,
        Yes,

        _Other(bool),
    }

    impl From<DbcClosed> for bool {
        fn from (val: DbcClosed) -> bool {
            match val {
                DbcClosed::No => false,
                DbcClosed::Yes => true,

                DbcClosed::_Other(x) => x
            }
        }
    }


    impl Closed  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Closed {
                status: CanDataStatus::Unset,
                name:"Closed",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }
        pub fn get_as_def (&self) -> DbcClosed {
            match self.get_typed_value() {
                false => DbcClosed::No,
                true => DbcClosed::Yes,
            }

        }
        pub fn set_raw_value(&mut self, value: u8, data: &mut[u8]) {
            data.view_bits_mut::<Lsb0>()[4..5].store_le(value);

        }
        pub fn set_as_def (&mut self, signal_def: DbcClosed, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcClosed::No => Ok(self.set_raw_value(0, data)),
                DbcClosed::Yes => Ok(self.set_raw_value(1, data)),
                DbcClosed::_Other(x) => self.set_typed_value(x,data)
            }
        }

        fn get_typed_value(&self) -> bool {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Lsb0>()[4..5].store_le(value);

            Ok(())
        }

    } // MuxTest::Closed impl end


    impl fmt::Display for Closed {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Closed:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Closed {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Closed")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// MuxTest::Closed public api (CanDbcSignal trait)
    impl CanDbcSignal for Closed {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[4..5].load_le::<u8>();

                    let newval = value == 1;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                    };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                        self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MuxTest::Closed public api

    /// MuxTest::Direction
    ///
    /// STATE page (MUX_signal=0). Collides with MEASURE speed bits.

    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 5
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct Direction {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }

    // DBC definition for MsgID:322 Signal:direction
    #[derive(Serialize, Deserialize)]
    pub enum DbcDirection {
        Stop,
        Opening,
        Closing,
        Unknown,

        _Other(u8),
    }

    impl From<DbcDirection> for u8 {
        fn from (val: DbcDirection) -> u8 {
            match val {
                DbcDirection::Stop => 0_u8,
                DbcDirection::Opening => 1_u8,
                DbcDirection::Closing => 2_u8,
                DbcDirection::Unknown => 3_u8,

                DbcDirection::_Other(x) => x
            }
        }
    }


    impl Direction  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Direction {
                status: CanDataStatus::Unset,
                name:"Direction",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }
        pub fn get_as_def (&self) -> DbcDirection {
            match self.get_typed_value() {
                0_u8 => DbcDirection::Stop,
                1_u8 => DbcDirection::Opening,
                2_u8 => DbcDirection::Closing,
                3_u8 => DbcDirection::Unknown,
                _ => DbcDirection::_Other(self.get_typed_value()),
            }

        }
        pub fn set_raw_value(&mut self, value: u8, data: &mut[u8]) {
            data.view_bits_mut::<Lsb0>()[5..7].store_le(value);

        }
        pub fn set_as_def (&mut self, signal_def: DbcDirection, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcDirection::Stop => Ok(self.set_raw_value(0, data)),
                DbcDirection::Opening => Ok(self.set_raw_value(1, data)),
                DbcDirection::Closing => Ok(self.set_raw_value(2, data)),
                DbcDirection::Unknown => Ok(self.set_raw_value(3, data)),
                DbcDirection::_Other(x) => self.set_typed_value(x,data)
            }
        }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[5..7].store_le(value);

            Ok(())
        }

    } // MuxTest::Direction impl end


    impl fmt::Display for Direction {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Direction:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Direction {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Direction")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// MuxTest::Direction public api (CanDbcSignal trait)
    impl CanDbcSignal for Direction {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[5..7].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MuxTest::Direction public api

    /// MuxTest::Mode
    ///
    /// STATE page (MUX_signal=0). Test mode at bits 61..63.

    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 61
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct Mode {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<u8>,
    }

    // DBC definition for MsgID:322 Signal:mode
    #[derive(Serialize, Deserialize)]
    pub enum DbcMode {
        M0,
        M1,
        M2,
        M3,
        M4,
        M5,
        M6,
        M7,

        _Other(u8),
    }

    impl From<DbcMode> for u8 {
        fn from (val: DbcMode) -> u8 {
            match val {
                DbcMode::M0 => 0_u8,
                DbcMode::M1 => 1_u8,
                DbcMode::M2 => 2_u8,
                DbcMode::M3 => 3_u8,
                DbcMode::M4 => 4_u8,
                DbcMode::M5 => 5_u8,
                DbcMode::M6 => 6_u8,
                DbcMode::M7 => 7_u8,

                DbcMode::_Other(x) => x
            }
        }
    }


    impl Mode  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Mode {
                status: CanDataStatus::Unset,
                name:"Mode",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }
        pub fn get_as_def (&self) -> DbcMode {
            match self.get_typed_value() {
                0_u8 => DbcMode::M0,
                1_u8 => DbcMode::M1,
                2_u8 => DbcMode::M2,
                3_u8 => DbcMode::M3,
                4_u8 => DbcMode::M4,
                5_u8 => DbcMode::M5,
                6_u8 => DbcMode::M6,
                7_u8 => DbcMode::M7,
                _ => DbcMode::_Other(self.get_typed_value()),
            }

        }
        pub fn set_raw_value(&mut self, value: u8, data: &mut[u8]) {
            data.view_bits_mut::<Lsb0>()[61..64].store_le(value);

        }
        pub fn set_as_def (&mut self, signal_def: DbcMode, data: &mut[u8])-> Result<(),CanError> {
            match signal_def {
                DbcMode::M0 => Ok(self.set_raw_value(0, data)),
                DbcMode::M1 => Ok(self.set_raw_value(1, data)),
                DbcMode::M2 => Ok(self.set_raw_value(2, data)),
                DbcMode::M3 => Ok(self.set_raw_value(3, data)),
                DbcMode::M4 => Ok(self.set_raw_value(4, data)),
                DbcMode::M5 => Ok(self.set_raw_value(5, data)),
                DbcMode::M6 => Ok(self.set_raw_value(6, data)),
                DbcMode::M7 => Ok(self.set_raw_value(7, data)),
                DbcMode::_Other(x) => self.set_typed_value(x,data)
            }
        }

        fn get_typed_value(&self) -> u8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Lsb0>()[61..64].store_le(value);

            Ok(())
        }

    } // MuxTest::Mode impl end


    impl fmt::Display for Mode {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Mode:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Mode {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Mode")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// MuxTest::Mode public api (CanDbcSignal trait)
    impl CanDbcSignal for Mode {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[61..64].load_le::<u8>();

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MuxTest::Mode public api

    /// MuxTest::Speed
    ///
    /// MEASURE page (MUX_signal=1). Signed 10-bit, factor 0.1 m/s. Overlaps STATE page bits starting at bit 3.

    /// - Min: -51.2
    /// - Max: 51.1
    /// - Unit: "m/s"
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 3
    /// - Signal size: 10 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct Speed {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<f64>,
    }


    impl Speed  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Speed {
                status: CanDataStatus::Unset,
                name:"Speed",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> f64 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {

            if value < -51.2_f64 || 51.1_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-51.2..51.1]",value)));
            }
            let factor = 0.1_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            let value = u16::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[3..13].store_le(value);

            Ok(())
        }

    } // MuxTest::Speed impl end


    impl fmt::Display for Speed {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Speed:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Speed {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Speed")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// MuxTest::Speed public api (CanDbcSignal trait)
    impl CanDbcSignal for Speed {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[3..13].load_le::<u16>();

                    let value = i16::from_ne_bytes(value.to_ne_bytes());

                    let factor = 0.1_f64;
                    let offset = 0_f64;
                    let newval = (value as f64) * factor + offset;
                    let changed = match self.value {
                        None => true,
                        Some(old) => old != newval,
                };
                    self.value = Some(newval);
                    if changed {
                        self.status = CanDataStatus::Updated;
                        self.stamp = frame.stamp;
                    } else {
                       self.status = CanDataStatus::Unchanged;
                    }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MuxTest::Speed public api

    /// MuxTest::Temperature
    ///
    /// MEASURE page (MUX_signal=1). Signed 8-bit degC. Located at bit 13 to avoid overlap with speed.

    /// - Min: -128
    /// - Max: 127
    /// - Unit: "degC"
    /// - Receivers: INFOTAINMENT_CTRL
    /// - Start bit: 13
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[derive(Serialize, Deserialize)]
    pub struct Temperature {
        #[serde(skip)]

        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: Option<i8>,
    }


    impl Temperature  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Temperature {
                status: CanDataStatus::Unset,
                name:"Temperature",
                value: None,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= None;
            }

        fn get_typed_value(&self) -> i8 {
            self.value.unwrap_or_default()
        }

        fn set_typed_value(&mut self, value:i8, data:&mut [u8]) -> Result<(),CanError> {
            let value = u8::from_ne_bytes(value.to_ne_bytes());
            data.view_bits_mut::<Lsb0>()[13..21].store_le(value);

            Ok(())
        }

    } // MuxTest::Temperature impl end


    impl fmt::Display for Temperature {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Temperature:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Temperature {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Temperature")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }


    /// MuxTest::Temperature public api (CanDbcSignal trait)
    impl CanDbcSignal for Temperature {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Lsb0>()[13..21].load_le::<u8>();

                    let value = i8::from_ne_bytes(value.to_ne_bytes());

                    let changed = match self.value {
                        None => true,
                        Some(old) => old != value,
                    };
                    self.value = Some(value);
                    if changed {
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                } else {
                        self.status= CanDataStatus::Unchanged;
                }

                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:i8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::I8(self.get_typed_value())
        }


        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }


        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MuxTest::Temperature public api


    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;7],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 322,
                name: "MuxTest",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    MuxSignal::new(),
                    Open::new(),
                    Closed::new(),
                    Direction::new(),
                    Mode::new(),
                    Speed::new(),
                    Temperature::new(),

                ],
            })))
        }


        pub fn set_values(&mut self, mux_signal: u8, open: bool, closed: bool, direction: u8, mode: u8, speed: f64, temperature: i8, frame: &mut[u8]) -> Result<&mut Self, CanError> {


            let __mux_raw_value: u64 = mux_signal as u64;
            println!("RLM __mux_raw_value{}",__mux_raw_value);

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(mux_signal), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error mux_signal:U8")),
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[1]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::Bool(open), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error open:Bool")),
                }
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[2]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::Bool(closed), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error closed:Bool")),
                }
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[3]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::U8(direction), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error direction:U8")),
                }
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[4]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::U8(mode), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error mode:U8")),
                }
            }

            if __mux_raw_value == 1 {
                match Rc::clone (&self.signals[5]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::F64(speed), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error speed:F64")),
                }
            }

            if __mux_raw_value == 1 {
                match Rc::clone (&self.signals[6]).try_borrow_mut() {
                    Ok(mut signal) => signal.set_value(CanDbcType::I8(temperature), frame)?,
                    Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error temperature:I8")),
                }
            }

            Ok(self)
        }
    }


    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error mux_signal:U8")),
            }

            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error open:Bool")),
            }

            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error closed:Bool")),
            }

            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error direction:U8")),
            }

            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error mode:U8")),
            }

            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error speed:F64")),
            }

            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error temperature:I8")),
            }

        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;

            let __mux_raw_value: u64 = (frame.data.view_bits::<Lsb0>()[0..2].load_le::<u8>()) as u64;

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error mux_signal:U8")),
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[1]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error open:Bool")),
                }
            } else {
                match Rc::clone (&self.signals[1]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error open:Bool")),
                }
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[2]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error closed:Bool")),
                }
            } else {
                match Rc::clone (&self.signals[2]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error closed:Bool")),
                }
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[3]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error direction:U8")),
                }
            } else {
                match Rc::clone (&self.signals[3]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error direction:U8")),
                }
            }

            if __mux_raw_value == 0 {
                match Rc::clone (&self.signals[4]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error mode:U8")),
                }
            } else {
                match Rc::clone (&self.signals[4]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error mode:U8")),
                }
            }

            if __mux_raw_value == 1 {
                match Rc::clone (&self.signals[5]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error speed:F64")),
                }
            } else {
                match Rc::clone (&self.signals[5]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error speed:F64")),
                }
            }

            if __mux_raw_value == 1 {
                match Rc::clone (&self.signals[6]).try_borrow_mut() {
                    Ok(mut signal) => self.listeners += signal.update(frame),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error temperature:I8")),
                }
            } else {
                match Rc::clone (&self.signals[6]).try_borrow_mut() {
                    Ok(mut signal) => signal.reset(),
                    Err(_) => return Err(CanError::new("signal-update-fail","Internal error temperature:I8")),
                }
            }

            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end MuxTest impl for CanDbcMessage

} // end MuxTest message

enum DbcMessages {
    MuxTest,

}

pub struct CanMsgPool {
    uid: &'static str,
    pool: [Rc<RefCell<Box<dyn CanDbcMessage>>>;1],
}

impl CanMsgPool {
    pub fn new(uid: &'static str) -> Self {
        CanMsgPool {
            uid: uid,
            pool: [
                MuxTest::DbcMessage::new(),

            ]
        }
    }
}

impl CanDbcPool for CanMsgPool {
    fn get_messages(&self) -> &[Rc<RefCell<Box<dyn CanDbcMessage>>>] {
        &self.pool
    }

    fn get_ids(&self) -> &[u32] {
        &[322]
    }

    fn get_mut(&self, canid: u32) -> Result<RefMut<'_, Box<dyn CanDbcMessage>>, CanError> {
        let search= self.pool.binary_search_by(|msg| msg.borrow().get_id().cmp(&canid));
        match search {
            Ok(idx) => {
                match self.pool[idx].try_borrow_mut() {
                    Err(_code) => Err(CanError::new("message-get_mut", "internal msg pool error")),
                    Ok(mut_ref) => Ok(mut_ref),
                }
            },
            Err(_) => Err(CanError::new("fail-canid-search", format!("canid:{} not found",canid))),
        }
    }

    fn update(&self, data: &CanMsgData) -> Result<RefMut<'_, Box<dyn CanDbcMessage>>, CanError> {
        let mut msg= match self.get_mut(data.canid) {
            Err(error) => return Err(error),
            Ok(msg_ref) => msg_ref,
        };
        msg.update(data)?;
        Ok(msg)
    }
 }
} // end dbc generated parser
