extern crate dbcparser;

use anyhow::{anyhow, Context, Result};
use clap::Parser;
use dbcparser::prelude::*;
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;

/// En-tête par défaut (celui de ton exemple)
const DEFAULT_HEADER: &str = r#"
// -----------------------------------------------------------------------
//              <- DBC file Rust mapping ->
// -----------------------------------------------------------------------
//  Do not edit this file it will be regenerated automatically by cargo.
//  Check:
//   - build.rs at project root for dynamically mapping
//   - example/demo/dbc-log/??? for static values
//  Reference: iot.bzh/Redpesk canbus-rs code generator
// -----------------------------------------------------------------------

// Tell rustfmt (stable) to skip formatting this whole file
#[rustfmt::skip]

#[allow(
    warnings,
    clippy::all,
    clippy::pedantic,
    clippy::nursery,
    clippy::redundant_field_names,
    clippy::similar_names
)]
"#;

#[derive(Debug, Deserialize, Serialize)]
struct OptionParser {
    infile: String,
    outfile: String,
    uid: String,
    header_file: Option<String>,
    no_header: bool,
    whitelist: Option<String>,
    blacklist: Option<String>,
}

/// Parse une liste d'identifiants CAN sous forme "0x101,0x121,289" etc.
/// Accepte hex (avec/ sans 0x) et décimal, séparés par virgules/espaces.
fn parse_id_list(input: &str) -> Result<Vec<u32>> {
    let mut out = Vec::new();
    for raw in input.split([',', ' ', '\n', '\t']).map(str::trim).filter(|s| !s.is_empty()) {
        let v = if let Some(stripped) = raw.strip_prefix("0x").or_else(|| raw.strip_prefix("0X")) {
            u32::from_str_radix(stripped, 16).with_context(|| format!("invalid hex id: {raw}"))?
        } else if raw.chars().all(|c| c.is_ascii_hexdigit())
            && raw.len() > 1
            && raw.chars().any(|c| c.is_ascii_alphabetic())
        {
            // cas "ABC" (hex sans 0x)
            u32::from_str_radix(raw, 16).with_context(|| format!("invalid hex id: {raw}"))?
        } else {
            raw.parse::<u32>().with_context(|| format!("invalid decimal id: {raw}"))?
        };
        out.push(v);
    }
    Ok(out)
}

/// CLI
#[derive(Debug, Parser)]
#[command(name = "dbc-gen", version, about = "Generate Rust code from a DBC file")]
struct Cli {
    /// Input DBC file (required unless a YAML config is provided)
    #[arg(short = 'i', long = "in", value_name = "INFILE", required_unless_present = "config")]
    infile: Option<String>,

    /// Output Rust file path (required unless a YAML config is provided)
    #[arg(short = 'o', long = "out", value_name = "OUTFILE", required_unless_present = "config")]
    outfile: Option<String>,

    /// Optional UID (module/namespace root in generated code)
    #[arg(long, default_value = "DbcSimple")]
    uid: String,

    /// Header text file to prepend (overrides built-in header if provided)
    #[arg(long = "header-file")]
    header_file: Option<String>,

    /// Disable default header completely
    #[arg(long = "no-header", default_value_t = false)]
    no_header: bool,

    /// Whitelist CAN IDs (CSV, hex 0xABC or decimal): e.g. "0x101,0x121,201"
    #[arg(long = "whitelist")]
    whitelist: Option<String>,

    /// Blacklist CAN IDs (CSV, hex 0xABC or decimal): e.g. "0x101,0x121,201"
    #[arg(long = "blacklist")]
    blacklist: Option<String>,

    /// Load parameters from a YAML configuration file
    #[arg(long = "config", value_name = "YAML")]
    config: Option<String>,

    /// Save the effective parameters to this YAML file
    #[arg(long = "save-config", value_name = "YAML")]
    save_config: Option<String>,

    /// Verbose mode: print effective configuration as YAML
    #[arg(short = 'v', long = "verbose")]
    verbose: bool,
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    // Build effective options:
    // - If --config is provided: load from YAML
    // - Otherwise: use CLI values
    let options: OptionParser = if let Some(cfg_path) = &cli.config {
        let cfg_str = fs::read_to_string(cfg_path)
            .with_context(|| format!("cannot read config file: {cfg_path}"))?;
        serde_yaml::from_str(&cfg_str)
            .with_context(|| format!("invalid YAML configuration in {cfg_path}"))?
    } else {
        OptionParser {
            infile: cli
                .infile
                .clone()
                .expect("clap guarantees infile is provided when config is not"),
            outfile: cli
                .outfile
                .clone()
                .expect("clap guarantees outfile is provided when config is not"),
            uid: cli.uid.clone(),
            header_file: cli.header_file.clone(),
            no_header: cli.no_header,
            whitelist: cli.whitelist.clone(),
            blacklist: cli.blacklist.clone(),
        }
    };
    // Optionnel: validations supplémentaires (ex. existence du fichier d’entrée)
    if !Path::new(&options.infile).exists() {
        return Err(anyhow!("input file does not exist: {}", options.infile));
    }

    // Parse whitelist / blacklist from the *effective* options
    let whitelist_ids =
        if let Some(s) = &options.whitelist { parse_id_list(s)? } else { Vec::new() };

    let blacklist_ids =
        if let Some(s) = &options.blacklist { parse_id_list(s)? } else { Vec::new() };

    // Resolve header text
    let header: &'static str = if options.no_header {
        ""
    } else if let Some(path) = &options.header_file {
        fs::read_to_string(path)
            .with_context(|| format!("cannot read header file: {path}"))?
            .leak()
    } else {
        DEFAULT_HEADER
    };

    // Verbose mode + optional save-config
    if cli.verbose || cli.save_config.is_some() {
        let yaml =
            serde_yaml::to_string(&options).context("failed to serialize options to YAML")?;

        if let Some(path) = &cli.save_config {
            fs::write(path, &yaml)
                .with_context(|| format!("cannot write configuration YAML to {path}"))?;
            eprintln!("Configuration saved to YAML: {path}");
        }

        if cli.verbose {
            eprintln!("Effective configuration (YAML):\n{yaml}");
        }
    }

    // uid has to be 'static for DbcParser, so we leak it on purpose
    let uid_static: &'static str = Box::leak(options.uid.clone().into_boxed_str());

    DbcParser::new(uid_static)
        .dbcfile(&options.infile)
        .outfile(&options.outfile)
        .header(header)
        .range_check(true)
        .serde_json(true)
        .whitelist(whitelist_ids)
        .blacklist(blacklist_ids)
        .generate()
        .map_err(|e| anyhow!("code generation failed: {e}"))?;

    eprintln!("Generated: {}", options.outfile);
    Ok(())
}
