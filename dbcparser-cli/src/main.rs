extern crate dbcparser;

use anyhow::{anyhow, Context, Result};
use clap::builder::BoolishValueParser;
use clap::{ArgAction, Parser};
use dbcparser::prelude::*;
use std::fs;

/// En-tête par défaut (celui de ton exemple)
const DEFAULT_HEADER: &str = r#"
// -----------------------------------------------------------------------
//              <- DBC file Rust mapping ->
// -----------------------------------------------------------------------
//  Do not edit this file it will be regenerated automatically by cargo.
//  Check:
//   - build.rs at project root for dynamically mapping
//   - example/demo/dbc-log/??? for static values
//  Reference: iot.bzh/Redpesk canbus-rs code generator
// -----------------------------------------------------------------------

// Tell rustfmt (stable) to skip formatting this whole file
#[rustfmt::skip]

#[allow(
    warnings,
    clippy::all,
    clippy::pedantic,
    clippy::nursery,
    clippy::redundant_field_names,
    clippy::similar_names
)]
"#;

/// Parse une liste d'identifiants CAN sous forme "0x101,0x121,289" etc.
/// Accepte hex (avec/ sans 0x) et décimal, séparés par virgules/espaces.
fn parse_id_list(input: &str) -> Result<Vec<u32>> {
    let mut out = Vec::new();
    for raw in input.split([',', ' ', '\n', '\t']).map(str::trim).filter(|s| !s.is_empty()) {
        let v = if let Some(stripped) = raw.strip_prefix("0x").or_else(|| raw.strip_prefix("0X")) {
            u32::from_str_radix(stripped, 16).with_context(|| format!("invalid hex id: {raw}"))?
        } else if raw.chars().all(|c| c.is_ascii_hexdigit())
            && raw.len() > 1
            && raw.chars().any(|c| c.is_ascii_alphabetic())
        {
            // cas "ABC" (hex sans 0x)
            u32::from_str_radix(raw, 16).with_context(|| format!("invalid hex id: {raw}"))?
        } else {
            raw.parse::<u32>().with_context(|| format!("invalid decimal id: {raw}"))?
        };
        out.push(v);
    }
    Ok(out)
}
/// CLI
#[derive(Debug, Parser)]
#[command(name = "dbc-gen", version, about = "Generate Rust code from a DBC file")]
struct Cli {
    /// Input DBC file (required)
    #[arg(short = 'i', long = "in", value_name = "INFILE", required = true)]
    infile: String,

    /// Output Rust file path (required)
    #[arg(short = 'o', long = "out", value_name = "OUTFILE", required = true)]
    outfile: String,

    /// Optional UID (module/namespace root in generated code)
    #[arg(long, default_value = "DbcSimple")]
    uid: String,

    /// Header text file to prepend (overrides built-in header if provided)
    #[arg(long = "header-file")]
    header_file: Option<String>,

    /// Disable default header completely
    #[arg(long = "no-header", default_value_t = false)]
    no_header: bool,

    /// Enable/disable serde_json in generated types
    #[arg(
    long = "serde-json",
    default_value_t = true,
    action = ArgAction::Set,                 // accept a value
    value_parser = BoolishValueParser::new() // true/false, yes/no, on/off, 1/0
    )]
    serde_json: bool,

    /// Whitelist CAN IDs (CSV, hex 0xABC or decimal): e.g. "0x101,0x121,201"
    #[arg(long = "whitelist")]
    whitelist: Option<String>,

    /// Blacklist CAN IDs (CSV, hex 0xABC or decimal): e.g. "0x101,0x121,201"
    #[arg(long = "blacklist")]
    blacklist: Option<String>,
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    // Optionnel: validations supplémentaires (ex. existence du fichier d’entrée)
    if !std::path::Path::new(&cli.infile).exists() {
        return Err(anyhow!("input file does not exist: {}", cli.infile));
    }

    let whitelist = if let Some(s) = &cli.whitelist { parse_id_list(s)? } else { Vec::new() };

    let blacklist = if let Some(s) = &cli.blacklist { parse_id_list(s)? } else { Vec::new() };

    let header: &'static str = if cli.no_header {
        ""
    } else if let Some(path) = &cli.header_file {
        fs::read_to_string(path)
            .with_context(|| format!("cannot read header file: {path}"))?
            .leak()
    } else {
        DEFAULT_HEADER
    };

    DbcParser::new(Box::leak(cli.uid.into_boxed_str()))
        .dbcfile(&cli.infile)
        .outfile(&cli.outfile)
        .header(header)
        .range_check(true)
        .serde_json(cli.serde_json)
        .whitelist(whitelist)
        .blacklist(blacklist)
        .generate()
        .map_err(|e| anyhow!("code generation failed: {e}"))?;

    eprintln!("Generated: {}", cli.outfile);
    Ok(())
}
