
// -----------------------------------------------------------------------
//              <- DBC file Rust mapping ->
// -----------------------------------------------------------------------
//  Do not edit this file it will be regenerated automatically by cargo.
//  Check:
//   - build.rs at project root for dynamically mapping
//   - example/demo/dbc-log/??? for static values
//  Reference: iot.bzh/Redpesk canbus-rs code generator
// -----------------------------------------------------------------------

// Tell rustfmt (stable) to skip formatting this whole file
#[rustfmt::skip]

#[allow(
    warnings,
    clippy::all,
    clippy::pedantic,
    clippy::nursery,
    clippy::redundant_field_names,
    clippy::similar_names
)]

// --------------------------------------------------------------
//       WARNING: Manual modification will be destroyed
// --------------------------------------------------------------
// - code generated from /home/ronan/Iot/rust/canforge-rs/dbcparser-cli/.tmpteb3pZ/../examples/bms/dbc/BMS.dbc (Tue Nov 18 12:44:15 2025)
// - update only with [dbc-parser|build.rs::DbcParser]
// - source code: https://github.com/redpesk-labs/canbus-rs
// - (C)IoT.bzh(2023), Author: Fulup Ar Foll, http://redpesk.bzh
// - License: $RP_BEGIN_LICENSE$ SPDX:MIT https://opensource.org/licenses/MIT $RP_END_LICENSE$
// -------------------------------------------------------------
mod DbcSimple {
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
extern crate serde;
extern crate bitvec;
use sockcan::prelude::*;
use std::cell::{RefCell,RefMut};
use std::rc::{Rc};

/// PLC_Main Message
/// - ID: 257 (0x101)
/// - Size: 5 bytes
/// - Transmitter: PLC
pub mod PlcMain { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        Diagack,
        EnableCharging,
        Sftymde1reset,
        CbTripReqRdcy,
        BreakerDiagReqRdcy,
        BreakerDiagReq,
        CbTripReq,
        DisconnectionReq,
        ContactorDiagReq,
        ConnectionReq,
        DayOfYear,
        BmuReset,
    }

    /// PlcMain::Diagack
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct Diagack {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl Diagack  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Diagack {
                status: CanDataStatus::Unset,
                name:"Diagack",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[31..32].store_be(value);
            Ok(())
        }

    } // PlcMain::Diagack impl end

    impl fmt::Display for Diagack {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Diagack:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Diagack {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Diagack")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// PlcMain::Diagack public api (CanDbcSignal trait)
    impl CanDbcSignal for Diagack {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[31..32].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PlcMain::Diagack public api

    /// PlcMain::EnableCharging
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct EnableCharging {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl EnableCharging  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(EnableCharging {
                status: CanDataStatus::Unset,
                name:"EnableCharging",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[30..31].store_be(value);
            Ok(())
        }

    } // PlcMain::EnableCharging impl end

    impl fmt::Display for EnableCharging {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("EnableCharging:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for EnableCharging {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("EnableCharging")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// PlcMain::EnableCharging public api (CanDbcSignal trait)
    impl CanDbcSignal for EnableCharging {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[30..31].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PlcMain::EnableCharging public api

    /// PlcMain::Sftymde1reset
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 27
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct Sftymde1reset {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl Sftymde1reset  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Sftymde1reset {
                status: CanDataStatus::Unset,
                name:"Sftymde1reset",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[28..29].store_be(value);
            Ok(())
        }

    } // PlcMain::Sftymde1reset impl end

    impl fmt::Display for Sftymde1reset {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Sftymde1reset:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Sftymde1reset {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Sftymde1reset")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// PlcMain::Sftymde1reset public api (CanDbcSignal trait)
    impl CanDbcSignal for Sftymde1reset {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[28..29].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PlcMain::Sftymde1reset public api

    /// PlcMain::CbTripReqRdcy
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct CbTripReqRdcy {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl CbTripReqRdcy  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(CbTripReqRdcy {
                status: CanDataStatus::Unset,
                name:"CbTripReqRdcy",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[26..27].store_be(value);
            Ok(())
        }

    } // PlcMain::CbTripReqRdcy impl end

    impl fmt::Display for CbTripReqRdcy {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("CbTripReqRdcy:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for CbTripReqRdcy {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("CbTripReqRdcy")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// PlcMain::CbTripReqRdcy public api (CanDbcSignal trait)
    impl CanDbcSignal for CbTripReqRdcy {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[26..27].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PlcMain::CbTripReqRdcy public api

    /// PlcMain::BreakerDiagReqRdcy
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct BreakerDiagReqRdcy {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl BreakerDiagReqRdcy  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(BreakerDiagReqRdcy {
                status: CanDataStatus::Unset,
                name:"BreakerDiagReqRdcy",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[24..25].store_be(value);
            Ok(())
        }

    } // PlcMain::BreakerDiagReqRdcy impl end

    impl fmt::Display for BreakerDiagReqRdcy {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("BreakerDiagReqRdcy:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for BreakerDiagReqRdcy {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("BreakerDiagReqRdcy")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// PlcMain::BreakerDiagReqRdcy public api (CanDbcSignal trait)
    impl CanDbcSignal for BreakerDiagReqRdcy {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[24..25].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PlcMain::BreakerDiagReqRdcy public api

    /// PlcMain::BreakerDiagReq
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 17
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct BreakerDiagReq {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl BreakerDiagReq  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(BreakerDiagReq {
                status: CanDataStatus::Unset,
                name:"BreakerDiagReq",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[22..23].store_be(value);
            Ok(())
        }

    } // PlcMain::BreakerDiagReq impl end

    impl fmt::Display for BreakerDiagReq {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("BreakerDiagReq:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for BreakerDiagReq {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("BreakerDiagReq")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// PlcMain::BreakerDiagReq public api (CanDbcSignal trait)
    impl CanDbcSignal for BreakerDiagReq {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[22..23].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PlcMain::BreakerDiagReq public api

    /// PlcMain::CbTripReq
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct CbTripReq {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl CbTripReq  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(CbTripReq {
                status: CanDataStatus::Unset,
                name:"CbTripReq",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[0..1].store_be(value);
            Ok(())
        }

    } // PlcMain::CbTripReq impl end

    impl fmt::Display for CbTripReq {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("CbTripReq:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for CbTripReq {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("CbTripReq")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// PlcMain::CbTripReq public api (CanDbcSignal trait)
    impl CanDbcSignal for CbTripReq {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[0..1].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PlcMain::CbTripReq public api

    /// PlcMain::DisconnectionReq
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 20
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DisconnectionReq {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl DisconnectionReq  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DisconnectionReq {
                status: CanDataStatus::Unset,
                name:"DisconnectionReq",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[19..20].store_be(value);
            Ok(())
        }

    } // PlcMain::DisconnectionReq impl end

    impl fmt::Display for DisconnectionReq {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DisconnectionReq:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DisconnectionReq {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DisconnectionReq")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// PlcMain::DisconnectionReq public api (CanDbcSignal trait)
    impl CanDbcSignal for DisconnectionReq {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[19..20].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PlcMain::DisconnectionReq public api

    /// PlcMain::ContactorDiagReq
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct ContactorDiagReq {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl ContactorDiagReq  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(ContactorDiagReq {
                status: CanDataStatus::Unset,
                name:"ContactorDiagReq",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[5..6].store_be(value);
            Ok(())
        }

    } // PlcMain::ContactorDiagReq impl end

    impl fmt::Display for ContactorDiagReq {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("ContactorDiagReq:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for ContactorDiagReq {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("ContactorDiagReq")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// PlcMain::ContactorDiagReq public api (CanDbcSignal trait)
    impl CanDbcSignal for ContactorDiagReq {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[5..6].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PlcMain::ContactorDiagReq public api

    /// PlcMain::ConnectionReq
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 23
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct ConnectionReq {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl ConnectionReq  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(ConnectionReq {
                status: CanDataStatus::Unset,
                name:"ConnectionReq",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[16..17].store_be(value);
            Ok(())
        }

    } // PlcMain::ConnectionReq impl end

    impl fmt::Display for ConnectionReq {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("ConnectionReq:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for ConnectionReq {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("ConnectionReq")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// PlcMain::ConnectionReq public api (CanDbcSignal trait)
    impl CanDbcSignal for ConnectionReq {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[16..17].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PlcMain::ConnectionReq public api

    /// PlcMain::DayOfYear
    /// - Min: 0
    /// - Max: 366
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 0
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DayOfYear {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl DayOfYear  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DayOfYear {
                status: CanDataStatus::Unset,
                name:"DayOfYear",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[7..16].store_be(value);
            Ok(())
        }

    } // PlcMain::DayOfYear impl end

    impl fmt::Display for DayOfYear {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DayOfYear:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DayOfYear {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DayOfYear")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// PlcMain::DayOfYear public api (CanDbcSignal trait)
    impl CanDbcSignal for DayOfYear {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[7..16].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PlcMain::DayOfYear public api

    /// PlcMain::BmuReset
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct BmuReset {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl BmuReset  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(BmuReset {
                status: CanDataStatus::Unset,
                name:"BmuReset",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[3..4].store_be(value);
            Ok(())
        }

    } // PlcMain::BmuReset impl end

    impl fmt::Display for BmuReset {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("BmuReset:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for BmuReset {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("BmuReset")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// PlcMain::BmuReset public api (CanDbcSignal trait)
    impl CanDbcSignal for BmuReset {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[3..4].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PlcMain::BmuReset public api

    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;12],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 257,
                name: "PlcMain",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    Diagack::new(),
                    EnableCharging::new(),
                    Sftymde1reset::new(),
                    CbTripReqRdcy::new(),
                    BreakerDiagReqRdcy::new(),
                    BreakerDiagReq::new(),
                    CbTripReq::new(),
                    DisconnectionReq::new(),
                    ContactorDiagReq::new(),
                    ConnectionReq::new(),
                    DayOfYear::new(),
                    BmuReset::new(),
                ],
            })))
        }

        pub fn set_values(&mut self, diagack: bool, enable_charging: bool, sftymde1reset: bool, cb_trip_req_rdcy: bool, breaker_diag_req_rdcy: bool, breaker_diag_req: bool, cb_trip_req: bool, disconnection_req: bool, contactor_diag_req: bool, connection_req: bool, day_of_year: u16, bmu_reset: bool, frame: &mut[u8]) -> Result<&mut Self, CanError> {

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(diagack), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error diagack:Bool")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(enable_charging), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error enable_charging:Bool")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(sftymde1reset), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sftymde1reset:Bool")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(cb_trip_req_rdcy), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error cb_trip_req_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(breaker_diag_req_rdcy), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error breaker_diag_req_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(breaker_diag_req), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error breaker_diag_req:Bool")),
            }
            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(cb_trip_req), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error cb_trip_req:Bool")),
            }
            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(disconnection_req), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error disconnection_req:Bool")),
            }
            match Rc::clone (&self.signals[8]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(contactor_diag_req), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error contactor_diag_req:Bool")),
            }
            match Rc::clone (&self.signals[9]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(connection_req), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error connection_req:Bool")),
            }
            match Rc::clone (&self.signals[10]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(day_of_year), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error day_of_year:U16")),
            }
            match Rc::clone (&self.signals[11]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(bmu_reset), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error bmu_reset:Bool")),
            }
            Ok(self)
        }
    }

    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error diagack:Bool")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error enable_charging:Bool")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sftymde1reset:Bool")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error cb_trip_req_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error breaker_diag_req_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error breaker_diag_req:Bool")),
            }
            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error cb_trip_req:Bool")),
            }
            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error disconnection_req:Bool")),
            }
            match Rc::clone (&self.signals[8]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error contactor_diag_req:Bool")),
            }
            match Rc::clone (&self.signals[9]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error connection_req:Bool")),
            }
            match Rc::clone (&self.signals[10]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error day_of_year:U16")),
            }
            match Rc::clone (&self.signals[11]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error bmu_reset:Bool")),
            }
        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error diagack:Bool")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error enable_charging:Bool")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sftymde1reset:Bool")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error cb_trip_req_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error breaker_diag_req_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error breaker_diag_req:Bool")),
            }
            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error cb_trip_req:Bool")),
            }
            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error disconnection_req:Bool")),
            }
            match Rc::clone (&self.signals[8]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error contactor_diag_req:Bool")),
            }
            match Rc::clone (&self.signals[9]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error connection_req:Bool")),
            }
            match Rc::clone (&self.signals[10]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error day_of_year:U16")),
            }
            match Rc::clone (&self.signals[11]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error bmu_reset:Bool")),
            }
            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end PlcMain impl for CanDbcMessage
} // end PlcMain message

/// PLC_Sub Message
/// - ID: 289 (0x121)
/// - Size: 3 bytes
/// - Transmitter: PLC
pub mod PlcSub { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        Subsftymde1reset,
        SubCbTripReqRdcy,
        SubBreakerDiagReqRdcy,
        SubBreakerDiagReq,
        SubCbTripReq,
        SubReset,
        SubDayOfYear,
    }

    /// PlcSub::Subsftymde1reset
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct Subsftymde1reset {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl Subsftymde1reset  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Subsftymde1reset {
                status: CanDataStatus::Unset,
                name:"Subsftymde1reset",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[11..12].store_be(value);
            Ok(())
        }

    } // PlcSub::Subsftymde1reset impl end

    impl fmt::Display for Subsftymde1reset {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Subsftymde1reset:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Subsftymde1reset {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Subsftymde1reset")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// PlcSub::Subsftymde1reset public api (CanDbcSignal trait)
    impl CanDbcSignal for Subsftymde1reset {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[11..12].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PlcSub::Subsftymde1reset public api

    /// PlcSub::SubCbTripReqRdcy
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 23
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SubCbTripReqRdcy {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl SubCbTripReqRdcy  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SubCbTripReqRdcy {
                status: CanDataStatus::Unset,
                name:"SubCbTripReqRdcy",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[16..17].store_be(value);
            Ok(())
        }

    } // PlcSub::SubCbTripReqRdcy impl end

    impl fmt::Display for SubCbTripReqRdcy {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SubCbTripReqRdcy:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SubCbTripReqRdcy {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SubCbTripReqRdcy")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// PlcSub::SubCbTripReqRdcy public api (CanDbcSignal trait)
    impl CanDbcSignal for SubCbTripReqRdcy {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[16..17].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PlcSub::SubCbTripReqRdcy public api

    /// PlcSub::SubBreakerDiagReqRdcy
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SubBreakerDiagReqRdcy {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl SubBreakerDiagReqRdcy  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SubBreakerDiagReqRdcy {
                status: CanDataStatus::Unset,
                name:"SubBreakerDiagReqRdcy",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[15..16].store_be(value);
            Ok(())
        }

    } // PlcSub::SubBreakerDiagReqRdcy impl end

    impl fmt::Display for SubBreakerDiagReqRdcy {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SubBreakerDiagReqRdcy:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SubBreakerDiagReqRdcy {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SubBreakerDiagReqRdcy")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// PlcSub::SubBreakerDiagReqRdcy public api (CanDbcSignal trait)
    impl CanDbcSignal for SubBreakerDiagReqRdcy {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[15..16].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PlcSub::SubBreakerDiagReqRdcy public api

    /// PlcSub::SubBreakerDiagReq
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SubBreakerDiagReq {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl SubBreakerDiagReq  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SubBreakerDiagReq {
                status: CanDataStatus::Unset,
                name:"SubBreakerDiagReq",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[14..15].store_be(value);
            Ok(())
        }

    } // PlcSub::SubBreakerDiagReq impl end

    impl fmt::Display for SubBreakerDiagReq {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SubBreakerDiagReq:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SubBreakerDiagReq {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SubBreakerDiagReq")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// PlcSub::SubBreakerDiagReq public api (CanDbcSignal trait)
    impl CanDbcSignal for SubBreakerDiagReq {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[14..15].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PlcSub::SubBreakerDiagReq public api

    /// PlcSub::SubCbTripReq
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SubCbTripReq {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl SubCbTripReq  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SubCbTripReq {
                status: CanDataStatus::Unset,
                name:"SubCbTripReq",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[9..10].store_be(value);
            Ok(())
        }

    } // PlcSub::SubCbTripReq impl end

    impl fmt::Display for SubCbTripReq {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SubCbTripReq:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SubCbTripReq {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SubCbTripReq")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// PlcSub::SubCbTripReq public api (CanDbcSignal trait)
    impl CanDbcSignal for SubCbTripReq {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[9..10].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PlcSub::SubCbTripReq public api

    /// PlcSub::SubReset
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SubReset {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl SubReset  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SubReset {
                status: CanDataStatus::Unset,
                name:"SubReset",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[12..13].store_be(value);
            Ok(())
        }

    } // PlcSub::SubReset impl end

    impl fmt::Display for SubReset {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SubReset:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SubReset {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SubReset")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// PlcSub::SubReset public api (CanDbcSignal trait)
    impl CanDbcSignal for SubReset {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[12..13].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PlcSub::SubReset public api

    /// PlcSub::SubDayOfYear
    /// - Min: 0
    /// - Max: 366
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 7
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SubDayOfYear {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl SubDayOfYear  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SubDayOfYear {
                status: CanDataStatus::Unset,
                name:"SubDayOfYear",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[0..9].store_be(value);
            Ok(())
        }

    } // PlcSub::SubDayOfYear impl end

    impl fmt::Display for SubDayOfYear {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SubDayOfYear:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SubDayOfYear {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SubDayOfYear")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// PlcSub::SubDayOfYear public api (CanDbcSignal trait)
    impl CanDbcSignal for SubDayOfYear {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[0..9].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end PlcSub::SubDayOfYear public api

    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;7],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 289,
                name: "PlcSub",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    Subsftymde1reset::new(),
                    SubCbTripReqRdcy::new(),
                    SubBreakerDiagReqRdcy::new(),
                    SubBreakerDiagReq::new(),
                    SubCbTripReq::new(),
                    SubReset::new(),
                    SubDayOfYear::new(),
                ],
            })))
        }

        pub fn set_values(&mut self, subsftymde1reset: bool, sub_cb_trip_req_rdcy: bool, sub_breaker_diag_req_rdcy: bool, sub_breaker_diag_req: bool, sub_cb_trip_req: bool, sub_reset: bool, sub_day_of_year: u16, frame: &mut[u8]) -> Result<&mut Self, CanError> {

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(subsftymde1reset), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error subsftymde1reset:Bool")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(sub_cb_trip_req_rdcy), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sub_cb_trip_req_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(sub_breaker_diag_req_rdcy), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sub_breaker_diag_req_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(sub_breaker_diag_req), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sub_breaker_diag_req:Bool")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(sub_cb_trip_req), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sub_cb_trip_req:Bool")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(sub_reset), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sub_reset:Bool")),
            }
            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(sub_day_of_year), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sub_day_of_year:U16")),
            }
            Ok(self)
        }
    }

    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error subsftymde1reset:Bool")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sub_cb_trip_req_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sub_breaker_diag_req_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sub_breaker_diag_req:Bool")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sub_cb_trip_req:Bool")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sub_reset:Bool")),
            }
            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sub_day_of_year:U16")),
            }
        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error subsftymde1reset:Bool")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sub_cb_trip_req_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sub_breaker_diag_req_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sub_breaker_diag_req:Bool")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sub_cb_trip_req:Bool")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sub_reset:Bool")),
            }
            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sub_day_of_year:U16")),
            }
            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end PlcSub impl for CanDbcMessage
} // end PlcSub message

/// Main_Safety Message
/// - ID: 513 (0x201)
/// - Size: 8 bytes
/// - Transmitter: Main
pub mod MainSafety { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        ContactorDiagProg,
        C4DiagOpn,
        HvnStatus,
        SafetyMode2Rdcy,
        SafetyMode1Rdcy,
        CbDiagResultRdcy,
        DischargeStopReq,
        SafetyMode2,
        SafetyMode1,
        C3DiagStk,
        C3DiagOpn,
        Pmd,
        Imd,
        DischargeUnavailable,
        Pmr,
        Imr,
        ChargeUnavailabe,
        CbStatus,
        CbDiagResult,
        C5Status,
        C5DiagStk,
        C4Status,
        C5DiagOpn,
        C3Status,
        C4DiagStk,
        BatOpStatus,
    }

    /// MainSafety::ContactorDiagProg
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 56
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct ContactorDiagProg {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl ContactorDiagProg  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(ContactorDiagProg {
                status: CanDataStatus::Unset,
                name:"ContactorDiagProg",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[63..64].store_be(value);
            Ok(())
        }

    } // MainSafety::ContactorDiagProg impl end

    impl fmt::Display for ContactorDiagProg {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("ContactorDiagProg:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for ContactorDiagProg {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("ContactorDiagProg")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::ContactorDiagProg public api (CanDbcSignal trait)
    impl CanDbcSignal for ContactorDiagProg {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[63..64].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::ContactorDiagProg public api

    /// MainSafety::C4DiagOpn
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct C4DiagOpn {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl C4DiagOpn  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(C4DiagOpn {
                status: CanDataStatus::Unset,
                name:"C4DiagOpn",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[31..32].store_be(value);
            Ok(())
        }

    } // MainSafety::C4DiagOpn impl end

    impl fmt::Display for C4DiagOpn {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("C4DiagOpn:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for C4DiagOpn {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("C4DiagOpn")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::C4DiagOpn public api (CanDbcSignal trait)
    impl CanDbcSignal for C4DiagOpn {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[31..32].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::C4DiagOpn public api

    /// MainSafety::HvnStatus
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 59
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct HvnStatus {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u8,
    }

    impl HvnStatus  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(HvnStatus {
                status: CanDataStatus::Unset,
                name:"HvnStatus",
                value: 0_u8,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u8;
        }

        fn get_typed_value(&self) -> u8 {
            self.value
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[60..63].store_be(value);
            Ok(())
        }

    } // MainSafety::HvnStatus impl end

    impl fmt::Display for HvnStatus {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("HvnStatus:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for HvnStatus {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("HvnStatus")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::HvnStatus public api (CanDbcSignal trait)
    impl CanDbcSignal for HvnStatus {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[60..63].load_be::<u8>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::HvnStatus public api

    /// MainSafety::SafetyMode2Rdcy
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 41
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SafetyMode2Rdcy {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl SafetyMode2Rdcy  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SafetyMode2Rdcy {
                status: CanDataStatus::Unset,
                name:"SafetyMode2Rdcy",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[46..47].store_be(value);
            Ok(())
        }

    } // MainSafety::SafetyMode2Rdcy impl end

    impl fmt::Display for SafetyMode2Rdcy {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SafetyMode2Rdcy:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SafetyMode2Rdcy {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SafetyMode2Rdcy")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::SafetyMode2Rdcy public api (CanDbcSignal trait)
    impl CanDbcSignal for SafetyMode2Rdcy {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[46..47].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::SafetyMode2Rdcy public api

    /// MainSafety::SafetyMode1Rdcy
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 42
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SafetyMode1Rdcy {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl SafetyMode1Rdcy  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SafetyMode1Rdcy {
                status: CanDataStatus::Unset,
                name:"SafetyMode1Rdcy",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[45..46].store_be(value);
            Ok(())
        }

    } // MainSafety::SafetyMode1Rdcy impl end

    impl fmt::Display for SafetyMode1Rdcy {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SafetyMode1Rdcy:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SafetyMode1Rdcy {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SafetyMode1Rdcy")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::SafetyMode1Rdcy public api (CanDbcSignal trait)
    impl CanDbcSignal for SafetyMode1Rdcy {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[45..46].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::SafetyMode1Rdcy public api

    /// MainSafety::CbDiagResultRdcy
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 40
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct CbDiagResultRdcy {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl CbDiagResultRdcy  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(CbDiagResultRdcy {
                status: CanDataStatus::Unset,
                name:"CbDiagResultRdcy",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[47..48].store_be(value);
            Ok(())
        }

    } // MainSafety::CbDiagResultRdcy impl end

    impl fmt::Display for CbDiagResultRdcy {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("CbDiagResultRdcy:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for CbDiagResultRdcy {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("CbDiagResultRdcy")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::CbDiagResultRdcy public api (CanDbcSignal trait)
    impl CanDbcSignal for CbDiagResultRdcy {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[47..48].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::CbDiagResultRdcy public api

    /// MainSafety::DischargeStopReq
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DischargeStopReq {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl DischargeStopReq  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DischargeStopReq {
                status: CanDataStatus::Unset,
                name:"DischargeStopReq",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[30..31].store_be(value);
            Ok(())
        }

    } // MainSafety::DischargeStopReq impl end

    impl fmt::Display for DischargeStopReq {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DischargeStopReq:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DischargeStopReq {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DischargeStopReq")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::DischargeStopReq public api (CanDbcSignal trait)
    impl CanDbcSignal for DischargeStopReq {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[30..31].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::DischargeStopReq public api

    /// MainSafety::SafetyMode2
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SafetyMode2 {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl SafetyMode2  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SafetyMode2 {
                status: CanDataStatus::Unset,
                name:"SafetyMode2",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[14..15].store_be(value);
            Ok(())
        }

    } // MainSafety::SafetyMode2 impl end

    impl fmt::Display for SafetyMode2 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SafetyMode2:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SafetyMode2 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SafetyMode2")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::SafetyMode2 public api (CanDbcSignal trait)
    impl CanDbcSignal for SafetyMode2 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[14..15].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::SafetyMode2 public api

    /// MainSafety::SafetyMode1
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SafetyMode1 {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl SafetyMode1  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SafetyMode1 {
                status: CanDataStatus::Unset,
                name:"SafetyMode1",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[13..14].store_be(value);
            Ok(())
        }

    } // MainSafety::SafetyMode1 impl end

    impl fmt::Display for SafetyMode1 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SafetyMode1:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SafetyMode1 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SafetyMode1")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::SafetyMode1 public api (CanDbcSignal trait)
    impl CanDbcSignal for SafetyMode1 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[13..14].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::SafetyMode1 public api

    /// MainSafety::C3DiagStk
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 43
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct C3DiagStk {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl C3DiagStk  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(C3DiagStk {
                status: CanDataStatus::Unset,
                name:"C3DiagStk",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[44..45].store_be(value);
            Ok(())
        }

    } // MainSafety::C3DiagStk impl end

    impl fmt::Display for C3DiagStk {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("C3DiagStk:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for C3DiagStk {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("C3DiagStk")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::C3DiagStk public api (CanDbcSignal trait)
    impl CanDbcSignal for C3DiagStk {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[44..45].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::C3DiagStk public api

    /// MainSafety::C3DiagOpn
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 44
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct C3DiagOpn {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl C3DiagOpn  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(C3DiagOpn {
                status: CanDataStatus::Unset,
                name:"C3DiagOpn",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[43..44].store_be(value);
            Ok(())
        }

    } // MainSafety::C3DiagOpn impl end

    impl fmt::Display for C3DiagOpn {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("C3DiagOpn:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for C3DiagOpn {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("C3DiagOpn")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::C3DiagOpn public api (CanDbcSignal trait)
    impl CanDbcSignal for C3DiagOpn {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[43..44].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::C3DiagOpn public api

    /// MainSafety::Pmd
    /// - Min: 0
    /// - Max: 500
    /// - Unit: "kW"
    /// - Receivers: Vector__XXX
    /// - Start bit: 23
    /// - Signal size: 10 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct Pmd {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: f64,
    }

    impl Pmd  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Pmd {
                status: CanDataStatus::Unset,
                name:"Pmd",
                value: 0_f64,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_f64;
        }

        fn get_typed_value(&self) -> f64 {
            self.value
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {
            if value < 0_f64 || 500_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [0..500]",value)));
            }
            let factor = 0.5_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            data.view_bits_mut::<Msb0>()[16..26].store_be(value);
            Ok(())
        }

    } // MainSafety::Pmd impl end

    impl fmt::Display for Pmd {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Pmd:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Pmd {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Pmd")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::Pmd public api (CanDbcSignal trait)
    impl CanDbcSignal for Pmd {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[16..26].load_be::<u16>();
                    let factor = 0.5_f64;
                    let offset = 0_f64;
                    let newval= (value as f64) * factor + offset;
                    if newval != self.value {
                        self.value= newval;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::Pmd public api

    /// MainSafety::Imd
    /// - Min: 0
    /// - Max: 500
    /// - Unit: "A"
    /// - Receivers: Vector__XXX
    /// - Start bit: 7
    /// - Signal size: 10 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct Imd {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: f64,
    }

    impl Imd  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Imd {
                status: CanDataStatus::Unset,
                name:"Imd",
                value: 0_f64,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_f64;
        }

        fn get_typed_value(&self) -> f64 {
            self.value
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {
            if value < 0_f64 || 500_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [0..500]",value)));
            }
            let factor = 0.5_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            data.view_bits_mut::<Msb0>()[0..10].store_be(value);
            Ok(())
        }

    } // MainSafety::Imd impl end

    impl fmt::Display for Imd {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Imd:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Imd {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Imd")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::Imd public api (CanDbcSignal trait)
    impl CanDbcSignal for Imd {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[0..10].load_be::<u16>();
                    let factor = 0.5_f64;
                    let offset = 0_f64;
                    let newval= (value as f64) * factor + offset;
                    if newval != self.value {
                        self.value= newval;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::Imd public api

    /// MainSafety::DischargeUnavailable
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 45
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DischargeUnavailable {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl DischargeUnavailable  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DischargeUnavailable {
                status: CanDataStatus::Unset,
                name:"DischargeUnavailable",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[42..43].store_be(value);
            Ok(())
        }

    } // MainSafety::DischargeUnavailable impl end

    impl fmt::Display for DischargeUnavailable {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DischargeUnavailable:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DischargeUnavailable {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DischargeUnavailable")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::DischargeUnavailable public api (CanDbcSignal trait)
    impl CanDbcSignal for DischargeUnavailable {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[42..43].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::DischargeUnavailable public api

    /// MainSafety::Pmr
    /// - Min: 0
    /// - Max: 250
    /// - Unit: "kW"
    /// - Receivers: Vector__XXX
    /// - Start bit: 55
    /// - Signal size: 9 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct Pmr {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: f64,
    }

    impl Pmr  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Pmr {
                status: CanDataStatus::Unset,
                name:"Pmr",
                value: 0_f64,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_f64;
        }

        fn get_typed_value(&self) -> f64 {
            self.value
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {
            if value < 0_f64 || 250_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [0..250]",value)));
            }
            let factor = 0.5_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            data.view_bits_mut::<Msb0>()[48..57].store_be(value);
            Ok(())
        }

    } // MainSafety::Pmr impl end

    impl fmt::Display for Pmr {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Pmr:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Pmr {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Pmr")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::Pmr public api (CanDbcSignal trait)
    impl CanDbcSignal for Pmr {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[48..57].load_be::<u16>();
                    let factor = 0.5_f64;
                    let offset = 0_f64;
                    let newval= (value as f64) * factor + offset;
                    if newval != self.value {
                        self.value= newval;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::Pmr public api

    /// MainSafety::Imr
    /// - Min: 0
    /// - Max: 250
    /// - Unit: "A"
    /// - Receivers: Vector__XXX
    /// - Start bit: 39
    /// - Signal size: 9 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct Imr {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: f64,
    }

    impl Imr  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(Imr {
                status: CanDataStatus::Unset,
                name:"Imr",
                value: 0_f64,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_f64;
        }

        fn get_typed_value(&self) -> f64 {
            self.value
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {
            if value < 0_f64 || 250_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [0..250]",value)));
            }
            let factor = 0.5_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            data.view_bits_mut::<Msb0>()[32..41].store_be(value);
            Ok(())
        }

    } // MainSafety::Imr impl end

    impl fmt::Display for Imr {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("Imr:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for Imr {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("Imr")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::Imr public api (CanDbcSignal trait)
    impl CanDbcSignal for Imr {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[32..41].load_be::<u16>();
                    let factor = 0.5_f64;
                    let offset = 0_f64;
                    let newval= (value as f64) * factor + offset;
                    if newval != self.value {
                        self.value= newval;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::Imr public api

    /// MainSafety::ChargeUnavailabe
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 46
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct ChargeUnavailabe {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl ChargeUnavailabe  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(ChargeUnavailabe {
                status: CanDataStatus::Unset,
                name:"ChargeUnavailabe",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[41..42].store_be(value);
            Ok(())
        }

    } // MainSafety::ChargeUnavailabe impl end

    impl fmt::Display for ChargeUnavailabe {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("ChargeUnavailabe:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for ChargeUnavailabe {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("ChargeUnavailabe")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::ChargeUnavailabe public api (CanDbcSignal trait)
    impl CanDbcSignal for ChargeUnavailabe {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[41..42].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::ChargeUnavailabe public api

    /// MainSafety::CbStatus
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 26
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct CbStatus {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl CbStatus  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(CbStatus {
                status: CanDataStatus::Unset,
                name:"CbStatus",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[29..30].store_be(value);
            Ok(())
        }

    } // MainSafety::CbStatus impl end

    impl fmt::Display for CbStatus {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("CbStatus:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for CbStatus {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("CbStatus")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::CbStatus public api (CanDbcSignal trait)
    impl CanDbcSignal for CbStatus {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[29..30].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::CbStatus public api

    /// MainSafety::CbDiagResult
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct CbDiagResult {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl CbDiagResult  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(CbDiagResult {
                status: CanDataStatus::Unset,
                name:"CbDiagResult",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[15..16].store_be(value);
            Ok(())
        }

    } // MainSafety::CbDiagResult impl end

    impl fmt::Display for CbDiagResult {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("CbDiagResult:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for CbDiagResult {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("CbDiagResult")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::CbDiagResult public api (CanDbcSignal trait)
    impl CanDbcSignal for CbDiagResult {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[15..16].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::CbDiagResult public api

    /// MainSafety::C5Status
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 27
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct C5Status {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl C5Status  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(C5Status {
                status: CanDataStatus::Unset,
                name:"C5Status",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[28..29].store_be(value);
            Ok(())
        }

    } // MainSafety::C5Status impl end

    impl fmt::Display for C5Status {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("C5Status:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for C5Status {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("C5Status")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::C5Status public api (CanDbcSignal trait)
    impl CanDbcSignal for C5Status {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[28..29].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::C5Status public api

    /// MainSafety::C5DiagStk
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 60
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct C5DiagStk {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl C5DiagStk  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(C5DiagStk {
                status: CanDataStatus::Unset,
                name:"C5DiagStk",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[59..60].store_be(value);
            Ok(())
        }

    } // MainSafety::C5DiagStk impl end

    impl fmt::Display for C5DiagStk {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("C5DiagStk:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for C5DiagStk {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("C5DiagStk")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::C5DiagStk public api (CanDbcSignal trait)
    impl CanDbcSignal for C5DiagStk {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[59..60].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::C5DiagStk public api

    /// MainSafety::C4Status
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 28
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct C4Status {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl C4Status  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(C4Status {
                status: CanDataStatus::Unset,
                name:"C4Status",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[27..28].store_be(value);
            Ok(())
        }

    } // MainSafety::C4Status impl end

    impl fmt::Display for C4Status {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("C4Status:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for C4Status {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("C4Status")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::C4Status public api (CanDbcSignal trait)
    impl CanDbcSignal for C4Status {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[27..28].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::C4Status public api

    /// MainSafety::C5DiagOpn
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 61
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct C5DiagOpn {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl C5DiagOpn  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(C5DiagOpn {
                status: CanDataStatus::Unset,
                name:"C5DiagOpn",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[58..59].store_be(value);
            Ok(())
        }

    } // MainSafety::C5DiagOpn impl end

    impl fmt::Display for C5DiagOpn {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("C5DiagOpn:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for C5DiagOpn {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("C5DiagOpn")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::C5DiagOpn public api (CanDbcSignal trait)
    impl CanDbcSignal for C5DiagOpn {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[58..59].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::C5DiagOpn public api

    /// MainSafety::C3Status
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct C3Status {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl C3Status  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(C3Status {
                status: CanDataStatus::Unset,
                name:"C3Status",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[26..27].store_be(value);
            Ok(())
        }

    } // MainSafety::C3Status impl end

    impl fmt::Display for C3Status {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("C3Status:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for C3Status {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("C3Status")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::C3Status public api (CanDbcSignal trait)
    impl CanDbcSignal for C3Status {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[26..27].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::C3Status public api

    /// MainSafety::C4DiagStk
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 62
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct C4DiagStk {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl C4DiagStk  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(C4DiagStk {
                status: CanDataStatus::Unset,
                name:"C4DiagStk",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[57..58].store_be(value);
            Ok(())
        }

    } // MainSafety::C4DiagStk impl end

    impl fmt::Display for C4DiagStk {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("C4DiagStk:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for C4DiagStk {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("C4DiagStk")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::C4DiagStk public api (CanDbcSignal trait)
    impl CanDbcSignal for C4DiagStk {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[57..58].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::C4DiagStk public api

    /// MainSafety::BatOpStatus
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 13
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct BatOpStatus {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u8,
    }

    impl BatOpStatus  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(BatOpStatus {
                status: CanDataStatus::Unset,
                name:"BatOpStatus",
                value: 0_u8,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u8;
        }

        fn get_typed_value(&self) -> u8 {
            self.value
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[10..13].store_be(value);
            Ok(())
        }

    } // MainSafety::BatOpStatus impl end

    impl fmt::Display for BatOpStatus {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("BatOpStatus:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for BatOpStatus {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("BatOpStatus")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainSafety::BatOpStatus public api (CanDbcSignal trait)
    impl CanDbcSignal for BatOpStatus {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[10..13].load_be::<u8>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainSafety::BatOpStatus public api

    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;26],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 513,
                name: "MainSafety",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    ContactorDiagProg::new(),
                    C4DiagOpn::new(),
                    HvnStatus::new(),
                    SafetyMode2Rdcy::new(),
                    SafetyMode1Rdcy::new(),
                    CbDiagResultRdcy::new(),
                    DischargeStopReq::new(),
                    SafetyMode2::new(),
                    SafetyMode1::new(),
                    C3DiagStk::new(),
                    C3DiagOpn::new(),
                    Pmd::new(),
                    Imd::new(),
                    DischargeUnavailable::new(),
                    Pmr::new(),
                    Imr::new(),
                    ChargeUnavailabe::new(),
                    CbStatus::new(),
                    CbDiagResult::new(),
                    C5Status::new(),
                    C5DiagStk::new(),
                    C4Status::new(),
                    C5DiagOpn::new(),
                    C3Status::new(),
                    C4DiagStk::new(),
                    BatOpStatus::new(),
                ],
            })))
        }

        pub fn set_values(&mut self, contactor_diag_prog: bool, c4_diag_opn: bool, hvn_status: u8, safety_mode2_rdcy: bool, safety_mode1_rdcy: bool, cb_diag_result_rdcy: bool, discharge_stop_req: bool, safety_mode2: bool, safety_mode1: bool, c3_diag_stk: bool, c3_diag_opn: bool, pmd: f64, imd: f64, discharge_unavailable: bool, pmr: f64, imr: f64, charge_unavailabe: bool, cb_status: bool, cb_diag_result: bool, c5_status: bool, c5_diag_stk: bool, c4_status: bool, c5_diag_opn: bool, c3_status: bool, c4_diag_stk: bool, bat_op_status: u8, frame: &mut[u8]) -> Result<&mut Self, CanError> {

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(contactor_diag_prog), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error contactor_diag_prog:Bool")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(c4_diag_opn), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error c4_diag_opn:Bool")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(hvn_status), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error hvn_status:U8")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(safety_mode2_rdcy), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error safety_mode2_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(safety_mode1_rdcy), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error safety_mode1_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(cb_diag_result_rdcy), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error cb_diag_result_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(discharge_stop_req), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error discharge_stop_req:Bool")),
            }
            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(safety_mode2), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error safety_mode2:Bool")),
            }
            match Rc::clone (&self.signals[8]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(safety_mode1), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error safety_mode1:Bool")),
            }
            match Rc::clone (&self.signals[9]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(c3_diag_stk), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error c3_diag_stk:Bool")),
            }
            match Rc::clone (&self.signals[10]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(c3_diag_opn), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error c3_diag_opn:Bool")),
            }
            match Rc::clone (&self.signals[11]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(pmd), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error pmd:F64")),
            }
            match Rc::clone (&self.signals[12]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(imd), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error imd:F64")),
            }
            match Rc::clone (&self.signals[13]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(discharge_unavailable), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error discharge_unavailable:Bool")),
            }
            match Rc::clone (&self.signals[14]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(pmr), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error pmr:F64")),
            }
            match Rc::clone (&self.signals[15]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(imr), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error imr:F64")),
            }
            match Rc::clone (&self.signals[16]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(charge_unavailabe), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error charge_unavailabe:Bool")),
            }
            match Rc::clone (&self.signals[17]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(cb_status), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error cb_status:Bool")),
            }
            match Rc::clone (&self.signals[18]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(cb_diag_result), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error cb_diag_result:Bool")),
            }
            match Rc::clone (&self.signals[19]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(c5_status), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error c5_status:Bool")),
            }
            match Rc::clone (&self.signals[20]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(c5_diag_stk), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error c5_diag_stk:Bool")),
            }
            match Rc::clone (&self.signals[21]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(c4_status), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error c4_status:Bool")),
            }
            match Rc::clone (&self.signals[22]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(c5_diag_opn), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error c5_diag_opn:Bool")),
            }
            match Rc::clone (&self.signals[23]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(c3_status), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error c3_status:Bool")),
            }
            match Rc::clone (&self.signals[24]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(c4_diag_stk), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error c4_diag_stk:Bool")),
            }
            match Rc::clone (&self.signals[25]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(bat_op_status), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error bat_op_status:U8")),
            }
            Ok(self)
        }
    }

    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error contactor_diag_prog:Bool")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error c4_diag_opn:Bool")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error hvn_status:U8")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error safety_mode2_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error safety_mode1_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error cb_diag_result_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error discharge_stop_req:Bool")),
            }
            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error safety_mode2:Bool")),
            }
            match Rc::clone (&self.signals[8]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error safety_mode1:Bool")),
            }
            match Rc::clone (&self.signals[9]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error c3_diag_stk:Bool")),
            }
            match Rc::clone (&self.signals[10]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error c3_diag_opn:Bool")),
            }
            match Rc::clone (&self.signals[11]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error pmd:F64")),
            }
            match Rc::clone (&self.signals[12]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error imd:F64")),
            }
            match Rc::clone (&self.signals[13]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error discharge_unavailable:Bool")),
            }
            match Rc::clone (&self.signals[14]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error pmr:F64")),
            }
            match Rc::clone (&self.signals[15]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error imr:F64")),
            }
            match Rc::clone (&self.signals[16]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error charge_unavailabe:Bool")),
            }
            match Rc::clone (&self.signals[17]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error cb_status:Bool")),
            }
            match Rc::clone (&self.signals[18]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error cb_diag_result:Bool")),
            }
            match Rc::clone (&self.signals[19]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error c5_status:Bool")),
            }
            match Rc::clone (&self.signals[20]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error c5_diag_stk:Bool")),
            }
            match Rc::clone (&self.signals[21]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error c4_status:Bool")),
            }
            match Rc::clone (&self.signals[22]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error c5_diag_opn:Bool")),
            }
            match Rc::clone (&self.signals[23]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error c3_status:Bool")),
            }
            match Rc::clone (&self.signals[24]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error c4_diag_stk:Bool")),
            }
            match Rc::clone (&self.signals[25]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error bat_op_status:U8")),
            }
        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error contactor_diag_prog:Bool")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error c4_diag_opn:Bool")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error hvn_status:U8")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error safety_mode2_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error safety_mode1_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error cb_diag_result_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error discharge_stop_req:Bool")),
            }
            match Rc::clone (&self.signals[7]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error safety_mode2:Bool")),
            }
            match Rc::clone (&self.signals[8]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error safety_mode1:Bool")),
            }
            match Rc::clone (&self.signals[9]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error c3_diag_stk:Bool")),
            }
            match Rc::clone (&self.signals[10]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error c3_diag_opn:Bool")),
            }
            match Rc::clone (&self.signals[11]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error pmd:F64")),
            }
            match Rc::clone (&self.signals[12]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error imd:F64")),
            }
            match Rc::clone (&self.signals[13]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error discharge_unavailable:Bool")),
            }
            match Rc::clone (&self.signals[14]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error pmr:F64")),
            }
            match Rc::clone (&self.signals[15]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error imr:F64")),
            }
            match Rc::clone (&self.signals[16]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error charge_unavailabe:Bool")),
            }
            match Rc::clone (&self.signals[17]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error cb_status:Bool")),
            }
            match Rc::clone (&self.signals[18]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error cb_diag_result:Bool")),
            }
            match Rc::clone (&self.signals[19]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error c5_status:Bool")),
            }
            match Rc::clone (&self.signals[20]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error c5_diag_stk:Bool")),
            }
            match Rc::clone (&self.signals[21]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error c4_status:Bool")),
            }
            match Rc::clone (&self.signals[22]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error c5_diag_opn:Bool")),
            }
            match Rc::clone (&self.signals[23]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error c3_status:Bool")),
            }
            match Rc::clone (&self.signals[24]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error c4_diag_stk:Bool")),
            }
            match Rc::clone (&self.signals[25]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error bat_op_status:U8")),
            }
            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end MainSafety impl for CanDbcMessage
} // end MainSafety message

/// Main_Volt_Current Message
/// - ID: 545 (0x221)
/// - Size: 8 bytes
/// - Transmitter: Main
pub mod MainVoltCurrent { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        RemainingRunTime,
        MinCellVoltage,
        MaxCellVoltage,
        BatVoltage,
        BatSoc,
        BatCurrent,
    }

    /// MainVoltCurrent::RemainingRunTime
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 63
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct RemainingRunTime {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u8,
    }

    impl RemainingRunTime  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(RemainingRunTime {
                status: CanDataStatus::Unset,
                name:"RemainingRunTime",
                value: 0_u8,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u8;
        }

        fn get_typed_value(&self) -> u8 {
            self.value
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[56..64].store_be(value);
            Ok(())
        }

    } // MainVoltCurrent::RemainingRunTime impl end

    impl fmt::Display for RemainingRunTime {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("RemainingRunTime:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for RemainingRunTime {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("RemainingRunTime")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainVoltCurrent::RemainingRunTime public api (CanDbcSignal trait)
    impl CanDbcSignal for RemainingRunTime {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[56..64].load_be::<u8>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainVoltCurrent::RemainingRunTime public api

    /// MainVoltCurrent::MinCellVoltage
    /// - Min: 0
    /// - Max: 5000
    /// - Unit: "mV"
    /// - Receivers: Vector__XXX
    /// - Start bit: 39
    /// - Signal size: 13 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct MinCellVoltage {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl MinCellVoltage  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(MinCellVoltage {
                status: CanDataStatus::Unset,
                name:"MinCellVoltage",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[32..45].store_be(value);
            Ok(())
        }

    } // MainVoltCurrent::MinCellVoltage impl end

    impl fmt::Display for MinCellVoltage {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("MinCellVoltage:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for MinCellVoltage {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("MinCellVoltage")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainVoltCurrent::MinCellVoltage public api (CanDbcSignal trait)
    impl CanDbcSignal for MinCellVoltage {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[32..45].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainVoltCurrent::MinCellVoltage public api

    /// MainVoltCurrent::MaxCellVoltage
    /// - Min: 0
    /// - Max: 5000
    /// - Unit: "mV"
    /// - Receivers: Vector__XXX
    /// - Start bit: 7
    /// - Signal size: 13 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct MaxCellVoltage {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl MaxCellVoltage  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(MaxCellVoltage {
                status: CanDataStatus::Unset,
                name:"MaxCellVoltage",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[0..13].store_be(value);
            Ok(())
        }

    } // MainVoltCurrent::MaxCellVoltage impl end

    impl fmt::Display for MaxCellVoltage {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("MaxCellVoltage:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for MaxCellVoltage {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("MaxCellVoltage")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainVoltCurrent::MaxCellVoltage public api (CanDbcSignal trait)
    impl CanDbcSignal for MaxCellVoltage {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[0..13].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainVoltCurrent::MaxCellVoltage public api

    /// MainVoltCurrent::BatVoltage
    /// - Min: 0
    /// - Max: 1500
    /// - Unit: "V"
    /// - Receivers: Vector__XXX
    /// - Start bit: 42
    /// - Signal size: 11 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct BatVoltage {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl BatVoltage  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(BatVoltage {
                status: CanDataStatus::Unset,
                name:"BatVoltage",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[45..56].store_be(value);
            Ok(())
        }

    } // MainVoltCurrent::BatVoltage impl end

    impl fmt::Display for BatVoltage {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("BatVoltage:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for BatVoltage {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("BatVoltage")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainVoltCurrent::BatVoltage public api (CanDbcSignal trait)
    impl CanDbcSignal for BatVoltage {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[45..56].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainVoltCurrent::BatVoltage public api

    /// MainVoltCurrent::BatSoc
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Vector__XXX
    /// - Start bit: 30
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct BatSoc {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u8,
    }

    impl BatSoc  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(BatSoc {
                status: CanDataStatus::Unset,
                name:"BatSoc",
                value: 0_u8,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u8;
        }

        fn get_typed_value(&self) -> u8 {
            self.value
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[25..32].store_be(value);
            Ok(())
        }

    } // MainVoltCurrent::BatSoc impl end

    impl fmt::Display for BatSoc {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("BatSoc:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for BatSoc {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("BatSoc")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainVoltCurrent::BatSoc public api (CanDbcSignal trait)
    impl CanDbcSignal for BatSoc {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[25..32].load_be::<u8>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainVoltCurrent::BatSoc public api

    /// MainVoltCurrent::BatCurrent
    /// - Min: -750
    /// - Max: 750
    /// - Unit: "A"
    /// - Receivers: Vector__XXX
    /// - Start bit: 10
    /// - Signal size: 12 bits
    /// - Factor: 0.5
    /// - Offset: -750
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct BatCurrent {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: f64,
    }

    impl BatCurrent  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(BatCurrent {
                status: CanDataStatus::Unset,
                name:"BatCurrent",
                value: 0_f64,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_f64;
        }

        fn get_typed_value(&self) -> f64 {
            self.value
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {
            if value < -750_f64 || 750_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-750..750]",value)));
            }
            let factor = 0.5_f64;
            let offset = -750_f64;
            let value = ((value - offset) / factor) as u16;
            data.view_bits_mut::<Msb0>()[13..25].store_be(value);
            Ok(())
        }

    } // MainVoltCurrent::BatCurrent impl end

    impl fmt::Display for BatCurrent {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("BatCurrent:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for BatCurrent {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("BatCurrent")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainVoltCurrent::BatCurrent public api (CanDbcSignal trait)
    impl CanDbcSignal for BatCurrent {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[13..25].load_be::<u16>();
                    let factor = 0.5_f64;
                    let offset = -750_f64;
                    let newval= (value as f64) * factor + offset;
                    if newval != self.value {
                        self.value= newval;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainVoltCurrent::BatCurrent public api

    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;6],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 545,
                name: "MainVoltCurrent",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    RemainingRunTime::new(),
                    MinCellVoltage::new(),
                    MaxCellVoltage::new(),
                    BatVoltage::new(),
                    BatSoc::new(),
                    BatCurrent::new(),
                ],
            })))
        }

        pub fn set_values(&mut self, remaining_run_time: u8, min_cell_voltage: u16, max_cell_voltage: u16, bat_voltage: u16, bat_soc: u8, bat_current: f64, frame: &mut[u8]) -> Result<&mut Self, CanError> {

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(remaining_run_time), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error remaining_run_time:U8")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(min_cell_voltage), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error min_cell_voltage:U16")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(max_cell_voltage), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error max_cell_voltage:U16")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(bat_voltage), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error bat_voltage:U16")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(bat_soc), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error bat_soc:U8")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(bat_current), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error bat_current:F64")),
            }
            Ok(self)
        }
    }

    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error remaining_run_time:U8")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error min_cell_voltage:U16")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error max_cell_voltage:U16")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error bat_voltage:U16")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error bat_soc:U8")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error bat_current:F64")),
            }
        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error remaining_run_time:U8")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error min_cell_voltage:U16")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error max_cell_voltage:U16")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error bat_voltage:U16")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error bat_soc:U8")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error bat_current:F64")),
            }
            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end MainVoltCurrent impl for CanDbcMessage
} // end MainVoltCurrent message

/// Main_Temp Message
/// - ID: 577 (0x241)
/// - Size: 8 bytes
/// - Transmitter: Main
pub mod MainTemp { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        MedConnTemp,
        TotalDchgNrj,
        MinCellTemp,
        MaxConnTemp,
        MaxCellTemp,
        ExtTemp,
        BmmTemp,
    }

    /// MainTemp::MedConnTemp
    /// - Min: -70
    /// - Max: 120
    /// - Unit: "C"
    /// - Receivers: Vector__XXX
    /// - Start bit: 47
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -70
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct MedConnTemp {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: f64,
    }

    impl MedConnTemp  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(MedConnTemp {
                status: CanDataStatus::Unset,
                name:"MedConnTemp",
                value: 0_f64,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_f64;
        }

        fn get_typed_value(&self) -> f64 {
            self.value
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {
            if value < -70_f64 || 120_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-70..120]",value)));
            }
            let factor = 1_f64;
            let offset = -70_f64;
            let value = ((value - offset) / factor) as u8;
            data.view_bits_mut::<Msb0>()[40..48].store_be(value);
            Ok(())
        }

    } // MainTemp::MedConnTemp impl end

    impl fmt::Display for MedConnTemp {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("MedConnTemp:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for MedConnTemp {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("MedConnTemp")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainTemp::MedConnTemp public api (CanDbcSignal trait)
    impl CanDbcSignal for MedConnTemp {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[40..48].load_be::<u8>();
                    let factor = 1_f64;
                    let offset = -70_f64;
                    let newval= (value as f64) * factor + offset;
                    if newval != self.value {
                        self.value= newval;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainTemp::MedConnTemp public api

    /// MainTemp::TotalDchgNrj
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: "kWh"
    /// - Receivers: Vector__XXX
    /// - Start bit: 55
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct TotalDchgNrj {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl TotalDchgNrj  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(TotalDchgNrj {
                status: CanDataStatus::Unset,
                name:"TotalDchgNrj",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[48..64].store_be(value);
            Ok(())
        }

    } // MainTemp::TotalDchgNrj impl end

    impl fmt::Display for TotalDchgNrj {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("TotalDchgNrj:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for TotalDchgNrj {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("TotalDchgNrj")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainTemp::TotalDchgNrj public api (CanDbcSignal trait)
    impl CanDbcSignal for TotalDchgNrj {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[48..64].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainTemp::TotalDchgNrj public api

    /// MainTemp::MinCellTemp
    /// - Min: -70
    /// - Max: 120
    /// - Unit: "C"
    /// - Receivers: Vector__XXX
    /// - Start bit: 7
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -70
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct MinCellTemp {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: f64,
    }

    impl MinCellTemp  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(MinCellTemp {
                status: CanDataStatus::Unset,
                name:"MinCellTemp",
                value: 0_f64,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_f64;
        }

        fn get_typed_value(&self) -> f64 {
            self.value
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {
            if value < -70_f64 || 120_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-70..120]",value)));
            }
            let factor = 1_f64;
            let offset = -70_f64;
            let value = ((value - offset) / factor) as u8;
            data.view_bits_mut::<Msb0>()[0..8].store_be(value);
            Ok(())
        }

    } // MainTemp::MinCellTemp impl end

    impl fmt::Display for MinCellTemp {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("MinCellTemp:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for MinCellTemp {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("MinCellTemp")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainTemp::MinCellTemp public api (CanDbcSignal trait)
    impl CanDbcSignal for MinCellTemp {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[0..8].load_be::<u8>();
                    let factor = 1_f64;
                    let offset = -70_f64;
                    let newval= (value as f64) * factor + offset;
                    if newval != self.value {
                        self.value= newval;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainTemp::MinCellTemp public api

    /// MainTemp::MaxConnTemp
    /// - Min: -70
    /// - Max: 120
    /// - Unit: "C"
    /// - Receivers: Vector__XXX
    /// - Start bit: 23
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -70
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct MaxConnTemp {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: f64,
    }

    impl MaxConnTemp  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(MaxConnTemp {
                status: CanDataStatus::Unset,
                name:"MaxConnTemp",
                value: 0_f64,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_f64;
        }

        fn get_typed_value(&self) -> f64 {
            self.value
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {
            if value < -70_f64 || 120_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-70..120]",value)));
            }
            let factor = 1_f64;
            let offset = -70_f64;
            let value = ((value - offset) / factor) as u8;
            data.view_bits_mut::<Msb0>()[16..24].store_be(value);
            Ok(())
        }

    } // MainTemp::MaxConnTemp impl end

    impl fmt::Display for MaxConnTemp {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("MaxConnTemp:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for MaxConnTemp {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("MaxConnTemp")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainTemp::MaxConnTemp public api (CanDbcSignal trait)
    impl CanDbcSignal for MaxConnTemp {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[16..24].load_be::<u8>();
                    let factor = 1_f64;
                    let offset = -70_f64;
                    let newval= (value as f64) * factor + offset;
                    if newval != self.value {
                        self.value= newval;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainTemp::MaxConnTemp public api

    /// MainTemp::MaxCellTemp
    /// - Min: -70
    /// - Max: 120
    /// - Unit: "C"
    /// - Receivers: Vector__XXX
    /// - Start bit: 15
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -70
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct MaxCellTemp {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: f64,
    }

    impl MaxCellTemp  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(MaxCellTemp {
                status: CanDataStatus::Unset,
                name:"MaxCellTemp",
                value: 0_f64,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_f64;
        }

        fn get_typed_value(&self) -> f64 {
            self.value
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {
            if value < -70_f64 || 120_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-70..120]",value)));
            }
            let factor = 1_f64;
            let offset = -70_f64;
            let value = ((value - offset) / factor) as u8;
            data.view_bits_mut::<Msb0>()[8..16].store_be(value);
            Ok(())
        }

    } // MainTemp::MaxCellTemp impl end

    impl fmt::Display for MaxCellTemp {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("MaxCellTemp:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for MaxCellTemp {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("MaxCellTemp")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainTemp::MaxCellTemp public api (CanDbcSignal trait)
    impl CanDbcSignal for MaxCellTemp {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[8..16].load_be::<u8>();
                    let factor = 1_f64;
                    let offset = -70_f64;
                    let newval= (value as f64) * factor + offset;
                    if newval != self.value {
                        self.value= newval;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainTemp::MaxCellTemp public api

    /// MainTemp::ExtTemp
    /// - Min: -70
    /// - Max: 120
    /// - Unit: "C"
    /// - Receivers: Vector__XXX
    /// - Start bit: 39
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -70
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct ExtTemp {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: f64,
    }

    impl ExtTemp  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(ExtTemp {
                status: CanDataStatus::Unset,
                name:"ExtTemp",
                value: 0_f64,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_f64;
        }

        fn get_typed_value(&self) -> f64 {
            self.value
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {
            if value < -70_f64 || 120_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-70..120]",value)));
            }
            let factor = 1_f64;
            let offset = -70_f64;
            let value = ((value - offset) / factor) as u8;
            data.view_bits_mut::<Msb0>()[32..40].store_be(value);
            Ok(())
        }

    } // MainTemp::ExtTemp impl end

    impl fmt::Display for ExtTemp {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("ExtTemp:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for ExtTemp {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("ExtTemp")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainTemp::ExtTemp public api (CanDbcSignal trait)
    impl CanDbcSignal for ExtTemp {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[32..40].load_be::<u8>();
                    let factor = 1_f64;
                    let offset = -70_f64;
                    let newval= (value as f64) * factor + offset;
                    if newval != self.value {
                        self.value= newval;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainTemp::ExtTemp public api

    /// MainTemp::BmmTemp
    /// - Min: -70
    /// - Max: 120
    /// - Unit: "C"
    /// - Receivers: Vector__XXX
    /// - Start bit: 31
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -70
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct BmmTemp {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: f64,
    }

    impl BmmTemp  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(BmmTemp {
                status: CanDataStatus::Unset,
                name:"BmmTemp",
                value: 0_f64,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_f64;
        }

        fn get_typed_value(&self) -> f64 {
            self.value
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {
            if value < -70_f64 || 120_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [-70..120]",value)));
            }
            let factor = 1_f64;
            let offset = -70_f64;
            let value = ((value - offset) / factor) as u8;
            data.view_bits_mut::<Msb0>()[24..32].store_be(value);
            Ok(())
        }

    } // MainTemp::BmmTemp impl end

    impl fmt::Display for BmmTemp {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("BmmTemp:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for BmmTemp {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("BmmTemp")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainTemp::BmmTemp public api (CanDbcSignal trait)
    impl CanDbcSignal for BmmTemp {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[24..32].load_be::<u8>();
                    let factor = 1_f64;
                    let offset = -70_f64;
                    let newval= (value as f64) * factor + offset;
                    if newval != self.value {
                        self.value= newval;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainTemp::BmmTemp public api

    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;7],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 577,
                name: "MainTemp",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    MedConnTemp::new(),
                    TotalDchgNrj::new(),
                    MinCellTemp::new(),
                    MaxConnTemp::new(),
                    MaxCellTemp::new(),
                    ExtTemp::new(),
                    BmmTemp::new(),
                ],
            })))
        }

        pub fn set_values(&mut self, med_conn_temp: f64, total_dchg_nrj: u16, min_cell_temp: f64, max_conn_temp: f64, max_cell_temp: f64, ext_temp: f64, bmm_temp: f64, frame: &mut[u8]) -> Result<&mut Self, CanError> {

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(med_conn_temp), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error med_conn_temp:F64")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(total_dchg_nrj), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error total_dchg_nrj:U16")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(min_cell_temp), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error min_cell_temp:F64")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(max_conn_temp), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error max_conn_temp:F64")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(max_cell_temp), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error max_cell_temp:F64")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(ext_temp), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error ext_temp:F64")),
            }
            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(bmm_temp), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error bmm_temp:F64")),
            }
            Ok(self)
        }
    }

    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error med_conn_temp:F64")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error total_dchg_nrj:U16")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error min_cell_temp:F64")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error max_conn_temp:F64")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error max_cell_temp:F64")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error ext_temp:F64")),
            }
            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error bmm_temp:F64")),
            }
        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error med_conn_temp:F64")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error total_dchg_nrj:U16")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error min_cell_temp:F64")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error max_conn_temp:F64")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error max_cell_temp:F64")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error ext_temp:F64")),
            }
            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error bmm_temp:F64")),
            }
            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end MainTemp impl for CanDbcMessage
} // end MainTemp message

/// Main_FaultCode Message
/// - ID: 609 (0x261)
/// - Size: 8 bytes
/// - Transmitter: Main
pub mod MainFaultCode { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        CbOpenCounter2,
        CbOpenCounter1,
        BatSoh,
        BatFaultCode2,
        BatFaultCode1,
    }

    /// MainFaultCode::CbOpenCounter2
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 63
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct CbOpenCounter2 {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u8,
    }

    impl CbOpenCounter2  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(CbOpenCounter2 {
                status: CanDataStatus::Unset,
                name:"CbOpenCounter2",
                value: 0_u8,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u8;
        }

        fn get_typed_value(&self) -> u8 {
            self.value
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[56..64].store_be(value);
            Ok(())
        }

    } // MainFaultCode::CbOpenCounter2 impl end

    impl fmt::Display for CbOpenCounter2 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("CbOpenCounter2:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for CbOpenCounter2 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("CbOpenCounter2")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainFaultCode::CbOpenCounter2 public api (CanDbcSignal trait)
    impl CanDbcSignal for CbOpenCounter2 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[56..64].load_be::<u8>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainFaultCode::CbOpenCounter2 public api

    /// MainFaultCode::CbOpenCounter1
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 55
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct CbOpenCounter1 {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u8,
    }

    impl CbOpenCounter1  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(CbOpenCounter1 {
                status: CanDataStatus::Unset,
                name:"CbOpenCounter1",
                value: 0_u8,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u8;
        }

        fn get_typed_value(&self) -> u8 {
            self.value
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[48..56].store_be(value);
            Ok(())
        }

    } // MainFaultCode::CbOpenCounter1 impl end

    impl fmt::Display for CbOpenCounter1 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("CbOpenCounter1:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for CbOpenCounter1 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("CbOpenCounter1")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainFaultCode::CbOpenCounter1 public api (CanDbcSignal trait)
    impl CanDbcSignal for CbOpenCounter1 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[48..56].load_be::<u8>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainFaultCode::CbOpenCounter1 public api

    /// MainFaultCode::BatSoh
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Vector__XXX
    /// - Start bit: 46
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct BatSoh {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u8,
    }

    impl BatSoh  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(BatSoh {
                status: CanDataStatus::Unset,
                name:"BatSoh",
                value: 0_u8,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u8;
        }

        fn get_typed_value(&self) -> u8 {
            self.value
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[41..48].store_be(value);
            Ok(())
        }

    } // MainFaultCode::BatSoh impl end

    impl fmt::Display for BatSoh {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("BatSoh:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for BatSoh {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("BatSoh")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainFaultCode::BatSoh public api (CanDbcSignal trait)
    impl CanDbcSignal for BatSoh {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[41..48].load_be::<u8>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainFaultCode::BatSoh public api

    /// MainFaultCode::BatFaultCode2
    /// - Min: 0
    /// - Max: 511
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 39
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct BatFaultCode2 {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl BatFaultCode2  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(BatFaultCode2 {
                status: CanDataStatus::Unset,
                name:"BatFaultCode2",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[32..41].store_be(value);
            Ok(())
        }

    } // MainFaultCode::BatFaultCode2 impl end

    impl fmt::Display for BatFaultCode2 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("BatFaultCode2:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for BatFaultCode2 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("BatFaultCode2")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainFaultCode::BatFaultCode2 public api (CanDbcSignal trait)
    impl CanDbcSignal for BatFaultCode2 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[32..41].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainFaultCode::BatFaultCode2 public api

    /// MainFaultCode::BatFaultCode1
    /// - Min: 0
    /// - Max: 4294967295
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 7
    /// - Signal size: 32 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct BatFaultCode1 {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u32,
    }

    impl BatFaultCode1  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(BatFaultCode1 {
                status: CanDataStatus::Unset,
                name:"BatFaultCode1",
                value: 0_u32,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u32;
        }

        fn get_typed_value(&self) -> u32 {
            self.value
        }

        fn set_typed_value(&mut self, value:u32, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[0..32].store_be(value);
            Ok(())
        }

    } // MainFaultCode::BatFaultCode1 impl end

    impl fmt::Display for BatFaultCode1 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("BatFaultCode1:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for BatFaultCode1 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("BatFaultCode1")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainFaultCode::BatFaultCode1 public api (CanDbcSignal trait)
    impl CanDbcSignal for BatFaultCode1 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[0..32].load_be::<u32>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u32= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U32(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainFaultCode::BatFaultCode1 public api

    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;5],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 609,
                name: "MainFaultCode",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    CbOpenCounter2::new(),
                    CbOpenCounter1::new(),
                    BatSoh::new(),
                    BatFaultCode2::new(),
                    BatFaultCode1::new(),
                ],
            })))
        }

        pub fn set_values(&mut self, cb_open_counter2: u8, cb_open_counter1: u8, bat_soh: u8, bat_fault_code2: u16, bat_fault_code1: u32, frame: &mut[u8]) -> Result<&mut Self, CanError> {

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(cb_open_counter2), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error cb_open_counter2:U8")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(cb_open_counter1), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error cb_open_counter1:U8")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(bat_soh), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error bat_soh:U8")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(bat_fault_code2), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error bat_fault_code2:U16")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U32(bat_fault_code1), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error bat_fault_code1:U32")),
            }
            Ok(self)
        }
    }

    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error cb_open_counter2:U8")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error cb_open_counter1:U8")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error bat_soh:U8")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error bat_fault_code2:U16")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error bat_fault_code1:U32")),
            }
        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error cb_open_counter2:U8")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error cb_open_counter1:U8")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error bat_soh:U8")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error bat_fault_code2:U16")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error bat_fault_code1:U32")),
            }
            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end MainFaultCode impl for CanDbcMessage
} // end MainFaultCode message

/// Main_Param_Bat Message
/// - ID: 641 (0x281)
/// - Size: 8 bytes
pub mod MainParamBat { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        BatFaultCode3,
        ParamSafetyVer,
        ParamFuncVer,
        SwMinorVer,
        SwMajorVer,
    }

    /// MainParamBat::BatFaultCode3
    /// - Min: 0
    /// - Max: 16777215
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 47
    /// - Signal size: 24 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct BatFaultCode3 {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u32,
    }

    impl BatFaultCode3  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(BatFaultCode3 {
                status: CanDataStatus::Unset,
                name:"BatFaultCode3",
                value: 0_u32,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u32;
        }

        fn get_typed_value(&self) -> u32 {
            self.value
        }

        fn set_typed_value(&mut self, value:u32, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[40..64].store_be(value);
            Ok(())
        }

    } // MainParamBat::BatFaultCode3 impl end

    impl fmt::Display for BatFaultCode3 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("BatFaultCode3:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for BatFaultCode3 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("BatFaultCode3")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainParamBat::BatFaultCode3 public api (CanDbcSignal trait)
    impl CanDbcSignal for BatFaultCode3 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[40..64].load_be::<u32>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u32= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U32(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainParamBat::BatFaultCode3 public api

    /// MainParamBat::ParamSafetyVer
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 25
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct ParamSafetyVer {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl ParamSafetyVer  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(ParamSafetyVer {
                status: CanDataStatus::Unset,
                name:"ParamSafetyVer",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[30..40].store_be(value);
            Ok(())
        }

    } // MainParamBat::ParamSafetyVer impl end

    impl fmt::Display for ParamSafetyVer {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("ParamSafetyVer:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for ParamSafetyVer {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("ParamSafetyVer")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainParamBat::ParamSafetyVer public api (CanDbcSignal trait)
    impl CanDbcSignal for ParamSafetyVer {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[30..40].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainParamBat::ParamSafetyVer public api

    /// MainParamBat::ParamFuncVer
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 19
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct ParamFuncVer {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl ParamFuncVer  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(ParamFuncVer {
                status: CanDataStatus::Unset,
                name:"ParamFuncVer",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[20..30].store_be(value);
            Ok(())
        }

    } // MainParamBat::ParamFuncVer impl end

    impl fmt::Display for ParamFuncVer {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("ParamFuncVer:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for ParamFuncVer {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("ParamFuncVer")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainParamBat::ParamFuncVer public api (CanDbcSignal trait)
    impl CanDbcSignal for ParamFuncVer {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[20..30].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainParamBat::ParamFuncVer public api

    /// MainParamBat::SwMinorVer
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 13
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SwMinorVer {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl SwMinorVer  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SwMinorVer {
                status: CanDataStatus::Unset,
                name:"SwMinorVer",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[10..20].store_be(value);
            Ok(())
        }

    } // MainParamBat::SwMinorVer impl end

    impl fmt::Display for SwMinorVer {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SwMinorVer:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SwMinorVer {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SwMinorVer")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainParamBat::SwMinorVer public api (CanDbcSignal trait)
    impl CanDbcSignal for SwMinorVer {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[10..20].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainParamBat::SwMinorVer public api

    /// MainParamBat::SwMajorVer
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 7
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SwMajorVer {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl SwMajorVer  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SwMajorVer {
                status: CanDataStatus::Unset,
                name:"SwMajorVer",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[0..10].store_be(value);
            Ok(())
        }

    } // MainParamBat::SwMajorVer impl end

    impl fmt::Display for SwMajorVer {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SwMajorVer:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SwMajorVer {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SwMajorVer")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainParamBat::SwMajorVer public api (CanDbcSignal trait)
    impl CanDbcSignal for SwMajorVer {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[0..10].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainParamBat::SwMajorVer public api

    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;5],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 641,
                name: "MainParamBat",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    BatFaultCode3::new(),
                    ParamSafetyVer::new(),
                    ParamFuncVer::new(),
                    SwMinorVer::new(),
                    SwMajorVer::new(),
                ],
            })))
        }

        pub fn set_values(&mut self, bat_fault_code3: u32, param_safety_ver: u16, param_func_ver: u16, sw_minor_ver: u16, sw_major_ver: u16, frame: &mut[u8]) -> Result<&mut Self, CanError> {

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U32(bat_fault_code3), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error bat_fault_code3:U32")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(param_safety_ver), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error param_safety_ver:U16")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(param_func_ver), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error param_func_ver:U16")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(sw_minor_ver), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sw_minor_ver:U16")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(sw_major_ver), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sw_major_ver:U16")),
            }
            Ok(self)
        }
    }

    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error bat_fault_code3:U32")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error param_safety_ver:U16")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error param_func_ver:U16")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sw_minor_ver:U16")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sw_major_ver:U16")),
            }
        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error bat_fault_code3:U32")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error param_safety_ver:U16")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error param_func_ver:U16")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sw_minor_ver:U16")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sw_major_ver:U16")),
            }
            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end MainParamBat impl for CanDbcMessage
} // end MainParamBat message

/// Main_Conf_Mod Message
/// - ID: 673 (0x2a1)
/// - Size: 8 bytes
/// - Transmitter: Main
pub mod MainConfMod { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        ModConfSeries,
    }

    /// MainConfMod::ModConfSeries
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 7
    /// - Signal size: 64 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct ModConfSeries {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u64,
    }

    impl ModConfSeries  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(ModConfSeries {
                status: CanDataStatus::Unset,
                name:"ModConfSeries",
                value: 0_u64,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u64;
        }

        fn get_typed_value(&self) -> u64 {
            self.value
        }

        fn set_typed_value(&mut self, value:u64, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[0..64].store_be(value);
            Ok(())
        }

    } // MainConfMod::ModConfSeries impl end

    impl fmt::Display for ModConfSeries {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("ModConfSeries:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for ModConfSeries {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("ModConfSeries")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainConfMod::ModConfSeries public api (CanDbcSignal trait)
    impl CanDbcSignal for ModConfSeries {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[0..64].load_be::<u64>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U64(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainConfMod::ModConfSeries public api

    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;1],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 673,
                name: "MainConfMod",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    ModConfSeries::new(),
                ],
            })))
        }

        pub fn set_values(&mut self, mod_conf_series: u64, frame: &mut[u8]) -> Result<&mut Self, CanError> {

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U64(mod_conf_series), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error mod_conf_series:U64")),
            }
            Ok(self)
        }
    }

    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error mod_conf_series:U64")),
            }
        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error mod_conf_series:U64")),
            }
            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end MainConfMod impl for CanDbcMessage
} // end MainConfMod message

/// Main_Conf_Bat Message
/// - ID: 705 (0x2c1)
/// - Size: 8 bytes
/// - Transmitter: Main
pub mod MainConfBat { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        ModNumber,
        ModConfParallel,
        BmmSer,
        BatCapacity,
    }

    /// MainConfBat::ModNumber
    /// - Min: 0
    /// - Max: 16
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 15
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct ModNumber {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u8,
    }

    impl ModNumber  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(ModNumber {
                status: CanDataStatus::Unset,
                name:"ModNumber",
                value: 0_u8,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u8;
        }

        fn get_typed_value(&self) -> u8 {
            self.value
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[8..13].store_be(value);
            Ok(())
        }

    } // MainConfBat::ModNumber impl end

    impl fmt::Display for ModNumber {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("ModNumber:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for ModNumber {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("ModNumber")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainConfBat::ModNumber public api (CanDbcSignal trait)
    impl CanDbcSignal for ModNumber {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[8..13].load_be::<u8>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainConfBat::ModNumber public api

    /// MainConfBat::ModConfParallel
    /// - Min: 0
    /// - Max: 31
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 7
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct ModConfParallel {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u8,
    }

    impl ModConfParallel  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(ModConfParallel {
                status: CanDataStatus::Unset,
                name:"ModConfParallel",
                value: 0_u8,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u8;
        }

        fn get_typed_value(&self) -> u8 {
            self.value
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[0..5].store_be(value);
            Ok(())
        }

    } // MainConfBat::ModConfParallel impl end

    impl fmt::Display for ModConfParallel {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("ModConfParallel:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for ModConfParallel {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("ModConfParallel")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainConfBat::ModConfParallel public api (CanDbcSignal trait)
    impl CanDbcSignal for ModConfParallel {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[0..5].load_be::<u8>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainConfBat::ModConfParallel public api

    /// MainConfBat::BmmSer
    /// - Min: 0
    /// - Max: 268435455
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 23
    /// - Signal size: 28 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct BmmSer {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u32,
    }

    impl BmmSer  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(BmmSer {
                status: CanDataStatus::Unset,
                name:"BmmSer",
                value: 0_u32,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u32;
        }

        fn get_typed_value(&self) -> u32 {
            self.value
        }

        fn set_typed_value(&mut self, value:u32, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[16..44].store_be(value);
            Ok(())
        }

    } // MainConfBat::BmmSer impl end

    impl fmt::Display for BmmSer {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("BmmSer:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for BmmSer {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("BmmSer")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainConfBat::BmmSer public api (CanDbcSignal trait)
    impl CanDbcSignal for BmmSer {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[16..44].load_be::<u32>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u32= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U32(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainConfBat::BmmSer public api

    /// MainConfBat::BatCapacity
    /// - Min: 0
    /// - Max: 400
    /// - Unit: "Ah"
    /// - Receivers: Vector__XXX
    /// - Start bit: 55
    /// - Signal size: 12 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct BatCapacity {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: f64,
    }

    impl BatCapacity  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(BatCapacity {
                status: CanDataStatus::Unset,
                name:"BatCapacity",
                value: 0_f64,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_f64;
        }

        fn get_typed_value(&self) -> f64 {
            self.value
        }

        fn set_typed_value(&mut self, value:f64, data:&mut [u8]) -> Result<(),CanError> {
            if value < 0_f64 || 400_f64 < value {
                return Err(CanError::new("invalid-signal-value",format!("value={} not in [0..400]",value)));
            }
            let factor = 0.1_f64;
            let offset = 0_f64;
            let value = ((value - offset) / factor) as u16;
            data.view_bits_mut::<Msb0>()[48..60].store_be(value);
            Ok(())
        }

    } // MainConfBat::BatCapacity impl end

    impl fmt::Display for BatCapacity {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("BatCapacity:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for BatCapacity {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("BatCapacity")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainConfBat::BatCapacity public api (CanDbcSignal trait)
    impl CanDbcSignal for BatCapacity {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[48..60].load_be::<u16>();
                    let factor = 0.1_f64;
                    let offset = 0_f64;
                    let newval= (value as f64) * factor + offset;
                    if newval != self.value {
                        self.value= newval;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:f64= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::F64(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainConfBat::BatCapacity public api

    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;4],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 705,
                name: "MainConfBat",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    ModNumber::new(),
                    ModConfParallel::new(),
                    BmmSer::new(),
                    BatCapacity::new(),
                ],
            })))
        }

        pub fn set_values(&mut self, mod_number: u8, mod_conf_parallel: u8, bmm_ser: u32, bat_capacity: f64, frame: &mut[u8]) -> Result<&mut Self, CanError> {

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(mod_number), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error mod_number:U8")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(mod_conf_parallel), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error mod_conf_parallel:U8")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U32(bmm_ser), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error bmm_ser:U32")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::F64(bat_capacity), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error bat_capacity:F64")),
            }
            Ok(self)
        }
    }

    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error mod_number:U8")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error mod_conf_parallel:U8")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error bmm_ser:U32")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error bat_capacity:F64")),
            }
        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error mod_number:U8")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error mod_conf_parallel:U8")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error bmm_ser:U32")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error bat_capacity:F64")),
            }
            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end MainConfBat impl for CanDbcMessage
} // end MainConfBat message

/// Sub_Safety Message
/// - ID: 769 (0x301)
/// - Size: 2 bytes
/// - Transmitter: Sub
pub mod SubSafety { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        SubSafetyMode2Rdcy,
        SubSafetyMode1Rdcy,
        SubCbDiagResultRdcy,
        SubSafetyMode2,
        SubSafetyMode1,
        SubCbStatus,
        SubCbDiagResult,
    }

    /// SubSafety::SubSafetyMode2Rdcy
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SubSafetyMode2Rdcy {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl SubSafetyMode2Rdcy  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SubSafetyMode2Rdcy {
                status: CanDataStatus::Unset,
                name:"SubSafetyMode2Rdcy",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[12..13].store_be(value);
            Ok(())
        }

    } // SubSafety::SubSafetyMode2Rdcy impl end

    impl fmt::Display for SubSafetyMode2Rdcy {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SubSafetyMode2Rdcy:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SubSafetyMode2Rdcy {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SubSafetyMode2Rdcy")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// SubSafety::SubSafetyMode2Rdcy public api (CanDbcSignal trait)
    impl CanDbcSignal for SubSafetyMode2Rdcy {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[12..13].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end SubSafety::SubSafetyMode2Rdcy public api

    /// SubSafety::SubSafetyMode1Rdcy
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SubSafetyMode1Rdcy {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl SubSafetyMode1Rdcy  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SubSafetyMode1Rdcy {
                status: CanDataStatus::Unset,
                name:"SubSafetyMode1Rdcy",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[9..10].store_be(value);
            Ok(())
        }

    } // SubSafety::SubSafetyMode1Rdcy impl end

    impl fmt::Display for SubSafetyMode1Rdcy {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SubSafetyMode1Rdcy:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SubSafetyMode1Rdcy {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SubSafetyMode1Rdcy")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// SubSafety::SubSafetyMode1Rdcy public api (CanDbcSignal trait)
    impl CanDbcSignal for SubSafetyMode1Rdcy {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[9..10].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end SubSafety::SubSafetyMode1Rdcy public api

    /// SubSafety::SubCbDiagResultRdcy
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SubCbDiagResultRdcy {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl SubCbDiagResultRdcy  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SubCbDiagResultRdcy {
                status: CanDataStatus::Unset,
                name:"SubCbDiagResultRdcy",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[14..15].store_be(value);
            Ok(())
        }

    } // SubSafety::SubCbDiagResultRdcy impl end

    impl fmt::Display for SubCbDiagResultRdcy {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SubCbDiagResultRdcy:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SubCbDiagResultRdcy {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SubCbDiagResultRdcy")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// SubSafety::SubCbDiagResultRdcy public api (CanDbcSignal trait)
    impl CanDbcSignal for SubCbDiagResultRdcy {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[14..15].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end SubSafety::SubCbDiagResultRdcy public api

    /// SubSafety::SubSafetyMode2
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SubSafetyMode2 {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl SubSafetyMode2  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SubSafetyMode2 {
                status: CanDataStatus::Unset,
                name:"SubSafetyMode2",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[2..3].store_be(value);
            Ok(())
        }

    } // SubSafety::SubSafetyMode2 impl end

    impl fmt::Display for SubSafetyMode2 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SubSafetyMode2:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SubSafetyMode2 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SubSafetyMode2")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// SubSafety::SubSafetyMode2 public api (CanDbcSignal trait)
    impl CanDbcSignal for SubSafetyMode2 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[2..3].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end SubSafety::SubSafetyMode2 public api

    /// SubSafety::SubSafetyMode1
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SubSafetyMode1 {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl SubSafetyMode1  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SubSafetyMode1 {
                status: CanDataStatus::Unset,
                name:"SubSafetyMode1",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[0..1].store_be(value);
            Ok(())
        }

    } // SubSafety::SubSafetyMode1 impl end

    impl fmt::Display for SubSafetyMode1 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SubSafetyMode1:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SubSafetyMode1 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SubSafetyMode1")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// SubSafety::SubSafetyMode1 public api (CanDbcSignal trait)
    impl CanDbcSignal for SubSafetyMode1 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[0..1].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end SubSafety::SubSafetyMode1 public api

    /// SubSafety::SubCbStatus
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SubCbStatus {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl SubCbStatus  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SubCbStatus {
                status: CanDataStatus::Unset,
                name:"SubCbStatus",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[7..8].store_be(value);
            Ok(())
        }

    } // SubSafety::SubCbStatus impl end

    impl fmt::Display for SubCbStatus {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SubCbStatus:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SubCbStatus {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SubCbStatus")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// SubSafety::SubCbStatus public api (CanDbcSignal trait)
    impl CanDbcSignal for SubCbStatus {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[7..8].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end SubSafety::SubCbStatus public api

    /// SubSafety::SubCbDiagResult
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SubCbDiagResult {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: bool,
    }

    impl SubCbDiagResult  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SubCbDiagResult {
                status: CanDataStatus::Unset,
                name:"SubCbDiagResult",
                value: false,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= false;
        }

        fn get_typed_value(&self) -> bool {
            self.value
        }

        fn set_typed_value(&mut self, value:bool, data:&mut [u8]) -> Result<(),CanError> {
            let value = value as u8;
            data.view_bits_mut::<Msb0>()[5..6].store_be(value);
            Ok(())
        }

    } // SubSafety::SubCbDiagResult impl end

    impl fmt::Display for SubCbDiagResult {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SubCbDiagResult:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SubCbDiagResult {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SubCbDiagResult")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// SubSafety::SubCbDiagResult public api (CanDbcSignal trait)
    impl CanDbcSignal for SubCbDiagResult {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[5..6].load_be::<u8>();
                    self.value= value == 1;
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:bool= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::Bool(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end SubSafety::SubCbDiagResult public api

    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;7],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 769,
                name: "SubSafety",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    SubSafetyMode2Rdcy::new(),
                    SubSafetyMode1Rdcy::new(),
                    SubCbDiagResultRdcy::new(),
                    SubSafetyMode2::new(),
                    SubSafetyMode1::new(),
                    SubCbStatus::new(),
                    SubCbDiagResult::new(),
                ],
            })))
        }

        pub fn set_values(&mut self, sub_safety_mode2_rdcy: bool, sub_safety_mode1_rdcy: bool, sub_cb_diag_result_rdcy: bool, sub_safety_mode2: bool, sub_safety_mode1: bool, sub_cb_status: bool, sub_cb_diag_result: bool, frame: &mut[u8]) -> Result<&mut Self, CanError> {

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(sub_safety_mode2_rdcy), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sub_safety_mode2_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(sub_safety_mode1_rdcy), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sub_safety_mode1_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(sub_cb_diag_result_rdcy), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sub_cb_diag_result_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(sub_safety_mode2), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sub_safety_mode2:Bool")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(sub_safety_mode1), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sub_safety_mode1:Bool")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(sub_cb_status), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sub_cb_status:Bool")),
            }
            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::Bool(sub_cb_diag_result), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sub_cb_diag_result:Bool")),
            }
            Ok(self)
        }
    }

    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sub_safety_mode2_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sub_safety_mode1_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sub_cb_diag_result_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sub_safety_mode2:Bool")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sub_safety_mode1:Bool")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sub_cb_status:Bool")),
            }
            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sub_cb_diag_result:Bool")),
            }
        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sub_safety_mode2_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sub_safety_mode1_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sub_cb_diag_result_rdcy:Bool")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sub_safety_mode2:Bool")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sub_safety_mode1:Bool")),
            }
            match Rc::clone (&self.signals[5]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sub_cb_status:Bool")),
            }
            match Rc::clone (&self.signals[6]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sub_cb_diag_result:Bool")),
            }
            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end SubSafety impl for CanDbcMessage
} // end SubSafety message

/// Sub_FaultCode Message
/// - ID: 801 (0x321)
/// - Size: 8 bytes
/// - Transmitter: Sub
pub mod SubFaultCode { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        SubParamSafetyVer,
        SubBatFaultCode2,
        SubSwMinorVer,
        SubSwMajorVer,
        SubBatFaultCode1,
    }

    /// SubFaultCode::SubParamSafetyVer
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 37
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SubParamSafetyVer {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl SubParamSafetyVer  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SubParamSafetyVer {
                status: CanDataStatus::Unset,
                name:"SubParamSafetyVer",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[34..44].store_be(value);
            Ok(())
        }

    } // SubFaultCode::SubParamSafetyVer impl end

    impl fmt::Display for SubParamSafetyVer {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SubParamSafetyVer:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SubParamSafetyVer {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SubParamSafetyVer")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// SubFaultCode::SubParamSafetyVer public api (CanDbcSignal trait)
    impl CanDbcSignal for SubParamSafetyVer {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[34..44].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end SubFaultCode::SubParamSafetyVer public api

    /// SubFaultCode::SubBatFaultCode2
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 39
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SubBatFaultCode2 {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u8,
    }

    impl SubBatFaultCode2  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SubBatFaultCode2 {
                status: CanDataStatus::Unset,
                name:"SubBatFaultCode2",
                value: 0_u8,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u8;
        }

        fn get_typed_value(&self) -> u8 {
            self.value
        }

        fn set_typed_value(&mut self, value:u8, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[32..34].store_be(value);
            Ok(())
        }

    } // SubFaultCode::SubBatFaultCode2 impl end

    impl fmt::Display for SubBatFaultCode2 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SubBatFaultCode2:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SubBatFaultCode2 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SubBatFaultCode2")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// SubFaultCode::SubBatFaultCode2 public api (CanDbcSignal trait)
    impl CanDbcSignal for SubBatFaultCode2 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[32..34].load_be::<u8>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u8= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U8(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end SubFaultCode::SubBatFaultCode2 public api

    /// SubFaultCode::SubSwMinorVer
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 49
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SubSwMinorVer {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl SubSwMinorVer  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SubSwMinorVer {
                status: CanDataStatus::Unset,
                name:"SubSwMinorVer",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[54..64].store_be(value);
            Ok(())
        }

    } // SubFaultCode::SubSwMinorVer impl end

    impl fmt::Display for SubSwMinorVer {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SubSwMinorVer:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SubSwMinorVer {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SubSwMinorVer")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// SubFaultCode::SubSwMinorVer public api (CanDbcSignal trait)
    impl CanDbcSignal for SubSwMinorVer {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[54..64].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end SubFaultCode::SubSwMinorVer public api

    /// SubFaultCode::SubSwMajorVer
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 43
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SubSwMajorVer {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl SubSwMajorVer  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SubSwMajorVer {
                status: CanDataStatus::Unset,
                name:"SubSwMajorVer",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[44..54].store_be(value);
            Ok(())
        }

    } // SubFaultCode::SubSwMajorVer impl end

    impl fmt::Display for SubSwMajorVer {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SubSwMajorVer:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SubSwMajorVer {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SubSwMajorVer")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// SubFaultCode::SubSwMajorVer public api (CanDbcSignal trait)
    impl CanDbcSignal for SubSwMajorVer {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[44..54].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end SubFaultCode::SubSwMajorVer public api

    /// SubFaultCode::SubBatFaultCode1
    /// - Min: 0
    /// - Max: 4294967295
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 7
    /// - Signal size: 32 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SubBatFaultCode1 {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u32,
    }

    impl SubBatFaultCode1  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SubBatFaultCode1 {
                status: CanDataStatus::Unset,
                name:"SubBatFaultCode1",
                value: 0_u32,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u32;
        }

        fn get_typed_value(&self) -> u32 {
            self.value
        }

        fn set_typed_value(&mut self, value:u32, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[0..32].store_be(value);
            Ok(())
        }

    } // SubFaultCode::SubBatFaultCode1 impl end

    impl fmt::Display for SubBatFaultCode1 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SubBatFaultCode1:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SubBatFaultCode1 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SubBatFaultCode1")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// SubFaultCode::SubBatFaultCode1 public api (CanDbcSignal trait)
    impl CanDbcSignal for SubBatFaultCode1 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[0..32].load_be::<u32>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u32= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U32(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end SubFaultCode::SubBatFaultCode1 public api

    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;5],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 801,
                name: "SubFaultCode",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    SubParamSafetyVer::new(),
                    SubBatFaultCode2::new(),
                    SubSwMinorVer::new(),
                    SubSwMajorVer::new(),
                    SubBatFaultCode1::new(),
                ],
            })))
        }

        pub fn set_values(&mut self, sub_param_safety_ver: u16, sub_bat_fault_code2: u8, sub_sw_minor_ver: u16, sub_sw_major_ver: u16, sub_bat_fault_code1: u32, frame: &mut[u8]) -> Result<&mut Self, CanError> {

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(sub_param_safety_ver), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sub_param_safety_ver:U16")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U8(sub_bat_fault_code2), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sub_bat_fault_code2:U8")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(sub_sw_minor_ver), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sub_sw_minor_ver:U16")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(sub_sw_major_ver), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sub_sw_major_ver:U16")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U32(sub_bat_fault_code1), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sub_bat_fault_code1:U32")),
            }
            Ok(self)
        }
    }

    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sub_param_safety_ver:U16")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sub_bat_fault_code2:U8")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sub_sw_minor_ver:U16")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sub_sw_major_ver:U16")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sub_bat_fault_code1:U32")),
            }
        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sub_param_safety_ver:U16")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sub_bat_fault_code2:U8")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sub_sw_minor_ver:U16")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sub_sw_major_ver:U16")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sub_bat_fault_code1:U32")),
            }
            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end SubFaultCode impl for CanDbcMessage
} // end SubFaultCode message

/// Main_Diag_Mde1 Message
/// - ID: 1281 (0x501)
/// - Size: 8 bytes
pub mod MainDiagMde1 { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        DiagCellUnv,
        DiagCellOvv,
        DiagCellOvt,
        DiagBBarOvt,
    }

    /// MainDiagMde1::DiagCellUnv
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: "N/A"
    /// - Receivers: Vector__XXX
    /// - Start bit: 23
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DiagCellUnv {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl DiagCellUnv  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DiagCellUnv {
                status: CanDataStatus::Unset,
                name:"DiagCellUnv",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[16..32].store_be(value);
            Ok(())
        }

    } // MainDiagMde1::DiagCellUnv impl end

    impl fmt::Display for DiagCellUnv {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DiagCellUnv:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DiagCellUnv {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DiagCellUnv")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainDiagMde1::DiagCellUnv public api (CanDbcSignal trait)
    impl CanDbcSignal for DiagCellUnv {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[16..32].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainDiagMde1::DiagCellUnv public api

    /// MainDiagMde1::DiagCellOvv
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: "N/A"
    /// - Receivers: Vector__XXX
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DiagCellOvv {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl DiagCellOvv  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DiagCellOvv {
                status: CanDataStatus::Unset,
                name:"DiagCellOvv",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[0..16].store_be(value);
            Ok(())
        }

    } // MainDiagMde1::DiagCellOvv impl end

    impl fmt::Display for DiagCellOvv {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DiagCellOvv:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DiagCellOvv {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DiagCellOvv")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainDiagMde1::DiagCellOvv public api (CanDbcSignal trait)
    impl CanDbcSignal for DiagCellOvv {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[0..16].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainDiagMde1::DiagCellOvv public api

    /// MainDiagMde1::DiagCellOvt
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: "N/A"
    /// - Receivers: Vector__XXX
    /// - Start bit: 39
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DiagCellOvt {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl DiagCellOvt  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DiagCellOvt {
                status: CanDataStatus::Unset,
                name:"DiagCellOvt",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[32..48].store_be(value);
            Ok(())
        }

    } // MainDiagMde1::DiagCellOvt impl end

    impl fmt::Display for DiagCellOvt {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DiagCellOvt:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DiagCellOvt {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DiagCellOvt")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainDiagMde1::DiagCellOvt public api (CanDbcSignal trait)
    impl CanDbcSignal for DiagCellOvt {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[32..48].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainDiagMde1::DiagCellOvt public api

    /// MainDiagMde1::DiagBBarOvt
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: "N/A"
    /// - Receivers: Vector__XXX
    /// - Start bit: 55
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DiagBBarOvt {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl DiagBBarOvt  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DiagBBarOvt {
                status: CanDataStatus::Unset,
                name:"DiagBBarOvt",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[48..64].store_be(value);
            Ok(())
        }

    } // MainDiagMde1::DiagBBarOvt impl end

    impl fmt::Display for DiagBBarOvt {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DiagBBarOvt:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DiagBBarOvt {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DiagBBarOvt")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainDiagMde1::DiagBBarOvt public api (CanDbcSignal trait)
    impl CanDbcSignal for DiagBBarOvt {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[48..64].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainDiagMde1::DiagBBarOvt public api

    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;4],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 1281,
                name: "MainDiagMde1",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    DiagCellUnv::new(),
                    DiagCellOvv::new(),
                    DiagCellOvt::new(),
                    DiagBBarOvt::new(),
                ],
            })))
        }

        pub fn set_values(&mut self, diag_cell_unv: u16, diag_cell_ovv: u16, diag_cell_ovt: u16, diag_b_bar_ovt: u16, frame: &mut[u8]) -> Result<&mut Self, CanError> {

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(diag_cell_unv), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error diag_cell_unv:U16")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(diag_cell_ovv), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error diag_cell_ovv:U16")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(diag_cell_ovt), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error diag_cell_ovt:U16")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(diag_b_bar_ovt), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error diag_b_bar_ovt:U16")),
            }
            Ok(self)
        }
    }

    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error diag_cell_unv:U16")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error diag_cell_ovv:U16")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error diag_cell_ovt:U16")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error diag_b_bar_ovt:U16")),
            }
        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error diag_cell_unv:U16")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error diag_cell_ovv:U16")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error diag_cell_ovt:U16")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error diag_b_bar_ovt:U16")),
            }
            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end MainDiagMde1 impl for CanDbcMessage
} // end MainDiagMde1 message

/// Main_Diag_Mde2 Message
/// - ID: 1313 (0x521)
/// - Size: 8 bytes
pub mod MainDiagMde2 { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        DiagCellIvldV,
        DiagCellIvldT,
        DiagBBarIvldT,
    }

    /// MainDiagMde2::DiagCellIvldV
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: "N/A"
    /// - Receivers: Vector__XXX
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DiagCellIvldV {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl DiagCellIvldV  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DiagCellIvldV {
                status: CanDataStatus::Unset,
                name:"DiagCellIvldV",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[0..16].store_be(value);
            Ok(())
        }

    } // MainDiagMde2::DiagCellIvldV impl end

    impl fmt::Display for DiagCellIvldV {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DiagCellIvldV:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DiagCellIvldV {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DiagCellIvldV")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainDiagMde2::DiagCellIvldV public api (CanDbcSignal trait)
    impl CanDbcSignal for DiagCellIvldV {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[0..16].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainDiagMde2::DiagCellIvldV public api

    /// MainDiagMde2::DiagCellIvldT
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: "N/A"
    /// - Receivers: Vector__XXX
    /// - Start bit: 23
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DiagCellIvldT {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl DiagCellIvldT  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DiagCellIvldT {
                status: CanDataStatus::Unset,
                name:"DiagCellIvldT",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[16..32].store_be(value);
            Ok(())
        }

    } // MainDiagMde2::DiagCellIvldT impl end

    impl fmt::Display for DiagCellIvldT {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DiagCellIvldT:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DiagCellIvldT {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DiagCellIvldT")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainDiagMde2::DiagCellIvldT public api (CanDbcSignal trait)
    impl CanDbcSignal for DiagCellIvldT {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[16..32].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainDiagMde2::DiagCellIvldT public api

    /// MainDiagMde2::DiagBBarIvldT
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: "N/A"
    /// - Receivers: Vector__XXX
    /// - Start bit: 39
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct DiagBBarIvldT {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl DiagBBarIvldT  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(DiagBBarIvldT {
                status: CanDataStatus::Unset,
                name:"DiagBBarIvldT",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[32..48].store_be(value);
            Ok(())
        }

    } // MainDiagMde2::DiagBBarIvldT impl end

    impl fmt::Display for DiagBBarIvldT {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("DiagBBarIvldT:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for DiagBBarIvldT {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("DiagBBarIvldT")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainDiagMde2::DiagBBarIvldT public api (CanDbcSignal trait)
    impl CanDbcSignal for DiagBBarIvldT {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[32..48].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainDiagMde2::DiagBBarIvldT public api

    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;3],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 1313,
                name: "MainDiagMde2",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    DiagCellIvldV::new(),
                    DiagCellIvldT::new(),
                    DiagBBarIvldT::new(),
                ],
            })))
        }

        pub fn set_values(&mut self, diag_cell_ivld_v: u16, diag_cell_ivld_t: u16, diag_b_bar_ivld_t: u16, frame: &mut[u8]) -> Result<&mut Self, CanError> {

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(diag_cell_ivld_v), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error diag_cell_ivld_v:U16")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(diag_cell_ivld_t), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error diag_cell_ivld_t:U16")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(diag_b_bar_ivld_t), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error diag_b_bar_ivld_t:U16")),
            }
            Ok(self)
        }
    }

    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error diag_cell_ivld_v:U16")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error diag_cell_ivld_t:U16")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error diag_b_bar_ivld_t:U16")),
            }
        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error diag_cell_ivld_v:U16")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error diag_cell_ivld_t:U16")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error diag_b_bar_ivld_t:U16")),
            }
            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end MainDiagMde2 impl for CanDbcMessage
} // end MainDiagMde2 message

enum DbcMessages {
    PlcMain,
    PlcSub,
    MainSafety,
    MainVoltCurrent,
    MainTemp,
    MainFaultCode,
    MainParamBat,
    MainConfMod,
    MainConfBat,
    SubSafety,
    SubFaultCode,
    MainDiagMde1,
    MainDiagMde2,
}

pub struct CanMsgPool {
    uid: &'static str,
    pool: [Rc<RefCell<Box<dyn CanDbcMessage>>>;13],
}

impl CanMsgPool {
    pub fn new(uid: &'static str) -> Self {
        CanMsgPool {
            uid: uid,
            pool: [
                PlcMain::DbcMessage::new(),
                PlcSub::DbcMessage::new(),
                MainSafety::DbcMessage::new(),
                MainVoltCurrent::DbcMessage::new(),
                MainTemp::DbcMessage::new(),
                MainFaultCode::DbcMessage::new(),
                MainParamBat::DbcMessage::new(),
                MainConfMod::DbcMessage::new(),
                MainConfBat::DbcMessage::new(),
                SubSafety::DbcMessage::new(),
                SubFaultCode::DbcMessage::new(),
                MainDiagMde1::DbcMessage::new(),
                MainDiagMde2::DbcMessage::new(),
            ]
        }
    }
}

impl CanDbcPool for CanMsgPool {
    fn get_messages(&self) -> &[Rc<RefCell<Box<dyn CanDbcMessage>>>] {
        &self.pool
    }

    fn get_ids(&self) -> &[u32] {
        &[257, 289, 513, 545, 577, 609, 641, 673, 705, 769, 801, 1281, 1313]
    }

    fn get_mut(&self, canid: u32) -> Result<RefMut<'_, Box<dyn CanDbcMessage>>, CanError> {
        let search= self.pool.binary_search_by(|msg| msg.borrow().get_id().cmp(&canid));
        match search {
            Ok(idx) => {
                match self.pool[idx].try_borrow_mut() {
                    Err(_code) => Err(CanError::new("message-get_mut", "internal msg pool error")),
                    Ok(mut_ref) => Ok(mut_ref),
                }
            },
            Err(_) => Err(CanError::new("fail-canid-search", format!("canid:{} not found",canid))),
        }
    }

    fn update(&self, data: &CanMsgData) -> Result<RefMut<'_, Box<dyn CanDbcMessage>>, CanError> {
        let mut msg= match self.get_mut(data.canid) {
            Err(error) => return Err(error),
            Ok(msg_ref) => msg_ref,
        };
        msg.update(data)?;
        Ok(msg)
    }
 }
} // end dbc generated parser
