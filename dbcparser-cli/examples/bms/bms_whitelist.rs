
// -----------------------------------------------------------------------
//              <- DBC file Rust mapping ->
// -----------------------------------------------------------------------
//  Do not edit this file it will be regenerated automatically by cargo.
//  Check:
//   - build.rs at project root for dynamically mapping
//   - example/demo/dbc-log/??? for static values
//  Reference: iot.bzh/Redpesk canbus-rs code generator
// -----------------------------------------------------------------------

// Tell rustfmt (stable) to skip formatting this whole file
#[rustfmt::skip]

#[allow(
    warnings,
    clippy::all,
    clippy::pedantic,
    clippy::nursery,
    clippy::redundant_field_names,
    clippy::similar_names
)]

// --------------------------------------------------------------
//       WARNING: Manual modification will be destroyed
// --------------------------------------------------------------
// - code generated from /home/ronan/Iot/rust/canforge-rs/dbcparser-cli/.tmpWKb8Vm/../examples/bms/dbc/BMS.dbc (Tue Nov 18 12:29:41 2025)
// - update only with [dbc-parser|build.rs::DbcParser]
// - source code: https://github.com/redpesk-labs/canbus-rs
// - (C)IoT.bzh(2023), Author: Fulup Ar Foll, http://redpesk.bzh
// - License: $RP_BEGIN_LICENSE$ SPDX:MIT https://opensource.org/licenses/MIT $RP_END_LICENSE$
// -------------------------------------------------------------
mod DbcSimple {
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
extern crate serde;
extern crate bitvec;
use sockcan::prelude::*;
use std::cell::{RefCell,RefMut};
use std::rc::{Rc};

/// Main_Param_Bat Message
/// - ID: 641 (0x281)
/// - Size: 8 bytes
pub mod MainParamBat { /// Message name space
    use sockcan::prelude::*;
    use bitvec::prelude::*;
    use std::any::Any;
    use std::cell::{RefCell};
    use std::rc::Rc;

    use std::fmt;

    use serde::{Deserialize, Serialize};
    pub enum DbcSignal {
        BatFaultCode3,
        ParamSafetyVer,
        ParamFuncVer,
        SwMinorVer,
        SwMajorVer,
    }

    /// MainParamBat::BatFaultCode3
    /// - Min: 0
    /// - Max: 16777215
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 47
    /// - Signal size: 24 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct BatFaultCode3 {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u32,
    }

    impl BatFaultCode3  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(BatFaultCode3 {
                status: CanDataStatus::Unset,
                name:"BatFaultCode3",
                value: 0_u32,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u32;
        }

        fn get_typed_value(&self) -> u32 {
            self.value
        }

        fn set_typed_value(&mut self, value:u32, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[40..64].store_be(value);
            Ok(())
        }

    } // MainParamBat::BatFaultCode3 impl end

    impl fmt::Display for BatFaultCode3 {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("BatFaultCode3:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for BatFaultCode3 {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("BatFaultCode3")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainParamBat::BatFaultCode3 public api (CanDbcSignal trait)
    impl CanDbcSignal for BatFaultCode3 {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[40..64].load_be::<u32>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u32= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U32(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainParamBat::BatFaultCode3 public api

    /// MainParamBat::ParamSafetyVer
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 25
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct ParamSafetyVer {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl ParamSafetyVer  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(ParamSafetyVer {
                status: CanDataStatus::Unset,
                name:"ParamSafetyVer",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[30..40].store_be(value);
            Ok(())
        }

    } // MainParamBat::ParamSafetyVer impl end

    impl fmt::Display for ParamSafetyVer {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("ParamSafetyVer:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for ParamSafetyVer {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("ParamSafetyVer")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainParamBat::ParamSafetyVer public api (CanDbcSignal trait)
    impl CanDbcSignal for ParamSafetyVer {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[30..40].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainParamBat::ParamSafetyVer public api

    /// MainParamBat::ParamFuncVer
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 19
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct ParamFuncVer {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl ParamFuncVer  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(ParamFuncVer {
                status: CanDataStatus::Unset,
                name:"ParamFuncVer",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[20..30].store_be(value);
            Ok(())
        }

    } // MainParamBat::ParamFuncVer impl end

    impl fmt::Display for ParamFuncVer {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("ParamFuncVer:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for ParamFuncVer {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("ParamFuncVer")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainParamBat::ParamFuncVer public api (CanDbcSignal trait)
    impl CanDbcSignal for ParamFuncVer {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[20..30].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainParamBat::ParamFuncVer public api

    /// MainParamBat::SwMinorVer
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 13
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SwMinorVer {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl SwMinorVer  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SwMinorVer {
                status: CanDataStatus::Unset,
                name:"SwMinorVer",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[10..20].store_be(value);
            Ok(())
        }

    } // MainParamBat::SwMinorVer impl end

    impl fmt::Display for SwMinorVer {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SwMinorVer:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SwMinorVer {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SwMinorVer")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainParamBat::SwMinorVer public api (CanDbcSignal trait)
    impl CanDbcSignal for SwMinorVer {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[10..20].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainParamBat::SwMinorVer public api

    /// MainParamBat::SwMajorVer
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    /// - Start bit: 7
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[derive(Serialize, Deserialize)]
    pub struct SwMajorVer {
        #[serde(skip)]
        callback: Option<RefCell<Box<dyn CanSigCtrl>>>,
        status: CanDataStatus,
        name: &'static str,
        stamp: u64,
        value: u16,
    }

    impl SwMajorVer  {
        pub fn new() -> Rc<RefCell<Box<dyn CanDbcSignal>>> {
            Rc::new(RefCell::new(Box::new(SwMajorVer {
                status: CanDataStatus::Unset,
                name:"SwMajorVer",
                value: 0_u16,
                stamp: 0,
                callback: None,
            })))
        }

        fn reset_value(&mut self) {
            self.value= 0_u16;
        }

        fn get_typed_value(&self) -> u16 {
            self.value
        }

        fn set_typed_value(&mut self, value:u16, data:&mut [u8]) -> Result<(),CanError> {
            data.view_bits_mut::<Msb0>()[0..10].store_be(value);
            Ok(())
        }

    } // MainParamBat::SwMajorVer impl end

    impl fmt::Display for SwMajorVer {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            let text=format!("SwMajorVer:{}", self.get_typed_value());
            fmt.pad(&text)
        }
    }

    impl fmt::Debug for SwMajorVer {
        fn fmt(&self, format: &mut fmt::Formatter<'_>) -> fmt::Result {
            format.debug_struct("SwMajorVer")
                .field("val", &self.get_typed_value())
                .field("stamp", &self.get_stamp())
                .field("status", &self.get_status())
                .finish()
        }
    }

    /// MainParamBat::SwMajorVer public api (CanDbcSignal trait)
    impl CanDbcSignal for SwMajorVer {

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_status(&self) -> CanDataStatus{
            self.status
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

        fn update(&mut self, frame: &CanMsgData) -> i32 {
            match frame.opcode {
                CanBcmOpCode::RxChanged => {
                    let value = frame.data.view_bits::<Msb0>()[0..10].load_be::<u16>();
                    if self.value != value {
                        self.value= value;
                        self.status= CanDataStatus::Updated;
                        self.stamp= frame.stamp;
                    } else {
                        self.status= CanDataStatus::Unchanged;
                    }
                },
                CanBcmOpCode::RxTimeout => {
                    self.status=CanDataStatus::Timeout;
                },
                _ => {
                    self.status=CanDataStatus::Error;
                },
            }
            match &self.callback {
                None => 0,
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => {println!("fail to get signal callback reference"); -1},
                        Ok(cb_ref) => cb_ref.sig_notification(self),
                    }
                }
            }
        }

        fn set_value(&mut self, value:CanDbcType, data:&mut [u8]) -> Result<(),CanError> {
            let value:u16= match value.cast() {
                Ok(val) => val,
                Err(error) => return Err(error)
            };
            self.set_typed_value(value, data)
        }

        fn get_value(&self) -> CanDbcType {
            CanDbcType::U16(self.get_typed_value())
        }

        fn to_json(&self) -> String {
            match serde_json::to_string(self) {
                Ok(json)=> json,
                _ => "serde-json-error".to_owned()
            }
        }

        fn reset(&mut self) {
            self.stamp=0;
            self.reset_value();
            self.status=CanDataStatus::Unset;
        }

        fn set_callback(&mut self, callback: Box<dyn CanSigCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

    } // end MainParamBat::SwMajorVer public api

    pub struct DbcMessage {
        callback: Option<RefCell<Box<dyn CanMsgCtrl>>>,
        signals: [Rc<RefCell<Box<dyn CanDbcSignal>>>;5],
        name: &'static str,
        status: CanBcmOpCode,
        listeners: i32,
        stamp: u64,
        id: u32,
    }

    impl DbcMessage {
        pub fn new() -> Rc<RefCell<Box <dyn CanDbcMessage>>> {
            Rc::new(RefCell::new(Box::new (DbcMessage {
                id: 641,
                name: "MainParamBat",
                status: CanBcmOpCode::Unknown,
                listeners: 0,
                stamp: 0,
                callback: None,
                signals: [
                    BatFaultCode3::new(),
                    ParamSafetyVer::new(),
                    ParamFuncVer::new(),
                    SwMinorVer::new(),
                    SwMajorVer::new(),
                ],
            })))
        }

        pub fn set_values(&mut self, bat_fault_code3: u32, param_safety_ver: u16, param_func_ver: u16, sw_minor_ver: u16, sw_major_ver: u16, frame: &mut[u8]) -> Result<&mut Self, CanError> {

            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U32(bat_fault_code3), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error bat_fault_code3:U32")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(param_safety_ver), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error param_safety_ver:U16")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(param_func_ver), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error param_func_ver:U16")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(sw_minor_ver), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sw_minor_ver:U16")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.set_value(CanDbcType::U16(sw_major_ver), frame)?,
                Err(_) => return Err(CanError::new("signal-set-values-fail","Internal error sw_major_ver:U16")),
            }
            Ok(self)
        }
    }

    impl CanDbcMessage for DbcMessage {
        fn reset(&mut self) -> Result<(), CanError> {
            self.status=CanBcmOpCode::Unknown;
            self.stamp=0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error bat_fault_code3:U32")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error param_safety_ver:U16")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error param_func_ver:U16")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sw_minor_ver:U16")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => signal.reset(),
                Err(_) => return Err(CanError::new("signal-reset-fail","Internal error sw_major_ver:U16")),
            }
        Ok(())
    }

        fn update(&mut self, frame: &CanMsgData) -> Result<(), CanError> {
            self.stamp= frame.stamp;
            self.status= frame.opcode;
            self.listeners= 0;
            match Rc::clone (&self.signals[0]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error bat_fault_code3:U32")),
            }
            match Rc::clone (&self.signals[1]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error param_safety_ver:U16")),
            }
            match Rc::clone (&self.signals[2]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error param_func_ver:U16")),
            }
            match Rc::clone (&self.signals[3]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sw_minor_ver:U16")),
            }
            match Rc::clone (&self.signals[4]).try_borrow_mut() {
                Ok(mut signal) => self.listeners += signal.update(frame),
                Err(_) => return Err(CanError::new("signal-update-fail","Internal error sw_major_ver:U16")),
            }
            match &self.callback {
                None => {},
                Some(callback) => {
                    match callback.try_borrow() {
                        Err(_) => println!("fail to get message callback reference"),
                        Ok(cb_ref) => cb_ref.msg_notification(self),
                    }
                }
            }
            Ok(())
        }

        fn get_signals(&self) -> &[Rc<RefCell<Box<dyn CanDbcSignal>>>] {
            &self.signals
        }

        fn get_listeners(&self) -> i32 {
            self.listeners
        }

        fn set_callback(&mut self, callback: Box<dyn CanMsgCtrl>)  {
            self.callback= Some(RefCell::new(callback));
        }

        fn get_name(&self) -> &'static str {
            self.name
        }

        fn get_status(&self) -> CanBcmOpCode {
            self.status
        }

        fn get_stamp(&self) -> u64 {
            self.stamp
        }

        fn get_id(&self) -> u32 {
            self.id
        }

        fn as_any(&mut self) -> &mut dyn Any {
            self
        }

    } // end MainParamBat impl for CanDbcMessage
} // end MainParamBat message

enum DbcMessages {
    MainParamBat,
}

pub struct CanMsgPool {
    uid: &'static str,
    pool: [Rc<RefCell<Box<dyn CanDbcMessage>>>;1],
}

impl CanMsgPool {
    pub fn new(uid: &'static str) -> Self {
        CanMsgPool {
            uid: uid,
            pool: [
                MainParamBat::DbcMessage::new(),
            ]
        }
    }
}

impl CanDbcPool for CanMsgPool {
    fn get_messages(&self) -> &[Rc<RefCell<Box<dyn CanDbcMessage>>>] {
        &self.pool
    }

    fn get_ids(&self) -> &[u32] {
        &[641]
    }

    fn get_mut(&self, canid: u32) -> Result<RefMut<'_, Box<dyn CanDbcMessage>>, CanError> {
        let search= self.pool.binary_search_by(|msg| msg.borrow().get_id().cmp(&canid));
        match search {
            Ok(idx) => {
                match self.pool[idx].try_borrow_mut() {
                    Err(_code) => Err(CanError::new("message-get_mut", "internal msg pool error")),
                    Ok(mut_ref) => Ok(mut_ref),
                }
            },
            Err(_) => Err(CanError::new("fail-canid-search", format!("canid:{} not found",canid))),
        }
    }

    fn update(&self, data: &CanMsgData) -> Result<RefMut<'_, Box<dyn CanDbcMessage>>, CanError> {
        let mut msg= match self.get_mut(data.canid) {
            Err(error) => return Err(error),
            Ok(msg_ref) => msg_ref,
        };
        msg.update(data)?;
        Ok(msg)
    }
 }
} // end dbc generated parser
